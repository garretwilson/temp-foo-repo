package com.garretwilson.urf;

import java.io.IOException;
import java.io.Reader;
import java.net.*;
import java.util.*;
import static java.util.Collections.*;

import static com.garretwilson.io.ReaderParser.*;

import com.garretwilson.io.ParseIOException;
import com.garretwilson.net.*;
import static com.garretwilson.net.URIUtilities.*;

import com.garretwilson.text.CharacterConstants;
import com.garretwilson.text.CharacterConstants.*;
import static com.garretwilson.util.ArrayUtilities.*;

import com.garretwilson.util.CollectionUtilities;
import com.garretwilson.util.Debug;

import static com.garretwilson.urf.URF.*;
import static com.garretwilson.urf.TURF.*;

/**Class that is able to construct an RDF data model from an XML-based
	RDF serialization. Each instance of an RDF processor maintains an internal
	RDF data model throughout its lifetime that is continually updated with
	every new RDF processing that occurs.
	<p>The RDF processor maintains RDF data in two separate formats: the RDF
	data model <code>RDF</code>, as well as a list of statements used to create
	the data model. The RDF data model may be replaced and its members modified,
	but these actions will not update the list of RDF statements. The RDF
	statements are only generated by the RDF processor itself as it parses
	RDF serializations, and are available to give information on the parser
	actions.</p>
	TODO If a property from a non-RDF namespace has (for example) a "resource" attribute (i.e. a property with no namespace), property resources are not correctly created and can cause endless loops when trying to analyze the namespace
@author Garret Wilson
*/
public class TURFProcessor extends AbstractURFProcessor
{

	/**Default constructor.*/
	public TURFProcessor()
	{
		this(new URF());  //create an URF data model to use
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param urf The RDF data model to use.
	*/
	public TURFProcessor(final URF urf)
	{
		super(urf);  //construct the parent class
	}

	/**Parses a resources.
	The current position must that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public void process(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		skipSeparators(reader);	//skip separators
		parseResourceList(reader, baseURI, CharacterConstants.NULL_CHAR);	//parse as list of resources
	}

	/**Skips over TURF separator characters in a reader.
	The new position will either be the that of the first non-separator character or the end of the input stream.
	@param reader The reader the contents of which to be parsed.
	@return The next character that will be returned the reader's {@link Reader#read()} operation, or <code>-1</code> if the end of the reader has been reached.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	*/
	protected static int skipSeparators(final Reader reader) throws IOException
	{
		return skip(reader, SEPARATORS);	//skip all separators
	}

	/**Parses a single resource and returns a proxy to the resource.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resources or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	*/
	public Resource parseResource(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		final URF urf=getURF();	//get the URF data model
		String label=null;	//the label of the resource, if any
		final List<URI> resourceURIs=new ArrayList<URI>();	//the URIs of the resource, if any
		final List<Resource> types=new ArrayList<Resource>();	//the types, if any
//TODO del if not needed		boolean hasProperties=false;	//whether a properties declaration is present
//TODO del		final Resource resource;	//we'll create an URF resource or a proxy and store it here
		DescriptionComponent lastDescriptionComponent=null;	//keep track of the last description component we found
		boolean finished=false;	//we'll see when we should be finished
		int c=peek(reader);	//peek the next character
		while(c>=0)	//while we haven't reached the end of the file
		{
Debug.trace("ready to check component character", (char)c);
			switch(c)	//check the current character
			{
				case LABEL_BEGIN:
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.LABEL);	//indicate which component we're parsing
Debug.trace("this is the beginning of a label");
					label=parseLabel(reader);	//parse the label
					break;
				case REFERENCE_BEGIN:
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.REFERENCE);	//indicate which component we're parsing
Debug.trace("found start of reference; ready to parse resources");
					check(reader, REFERENCE_BEGIN);	//read the beginning reference character
					final Resource[] referenceResources=parseResourceList(reader, baseURI, REFERENCE_END);	//parse the resources serving as references
Debug.trace("just parsed reference resources", Arrays.toString(referenceResources));
						//TODO save the reference resources and process them outside the loop, because then the types will be available
					for(final Resource referenceResource:referenceResources)	//look at each reference resource
					{
						resourceURIs.add(asURI(referenceResource));	//get the URI this resource represents
					}
Debug.trace("ready to check reference end");
					check(reader, REFERENCE_END);	//read the ending reference delimiter
Debug.trace("checked reference end, next character", peek(reader));
					break;
				case BOOLEAN_FALSE_BEGIN:	//false
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.REFERENCE);	//indicate which component we're parsing
					check(reader, BOOLEAN_FALSE_LEXICAL_FORM);	//make sure this is really "false"
					resourceURIs.add(BOOLEAN_FALSE_URI);	//create a URI for the resource
					types.add(getResourceProxy(null, URI_CLASS_URI));	//add a proxy to the Boolean class
					break;
				case BOOLEAN_TRUE_BEGIN:	//true
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.REFERENCE);	//indicate which component we're parsing
					check(reader, BOOLEAN_TRUE_LEXICAL_FORM);	//make sure this is really "true"
					resourceURIs.add(BOOLEAN_TRUE_URI);	//create a URI for the resource
					types.add(getResourceProxy(null, URI_CLASS_URI));	//add a proxy to the Boolean class
					break;
				case URI_BEGIN:
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.REFERENCE);	//indicate which component we're parsing
Debug.trace("ready to parse URI");
					final URI uri=parseURI(reader, baseURI);	//parse the URI
Debug.trace("found URI", uri);
					resourceURIs.add(createLexicalURI(URI_CLASS_URI, uri.toString()));	//create a URI for the resource
//Debug.trace("resourceURI", resourceURI, "ready to add URI class type");
					types.add(getResourceProxy(null, URI_CLASS_URI));	//add a proxy to the URI class
					//TODO add the correct type resource
					break;
				case TYPE_BEGIN:
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.TYPE);	//indicate which component we're parsing
Debug.trace("found start of types; ready to parse type resources");
/*TODO del
if(c=='^')
{
	Debug.trace("found start of types; next character", (char)reader.read(), (char)reader.read());
}
*/
//Debug.trace("found start of types; ready to parse type resources; next character is", (char)peek(reader));
					check(reader, TYPE_BEGIN);	//read the beginning type character
					final Resource[] typeResources=parseResourceList(reader, baseURI, TYPE_END);	//parse the resources serving as types
Debug.trace("just parsed type resources", Arrays.toString(typeResources));
					addAll(types, typeResources);	//add all the types we found
					check(reader, TYPE_END);	//read the ending type delimiter
					break;
				case PROPERTIES_BEGIN:
					lastDescriptionComponent=checkDescriptionComponent(lastDescriptionComponent, DescriptionComponent.PROPERTIES);	//indicate which component we're parsing
//					reader.reset();	//reset to the last mark, which was set right before the character we found
					finished=true;	//don't do any processing; we'll break out of the read loop and read the properties 
					break;
				default:	//if we don't recognize the character
					Debug.trace("we'll reset and consider ourselves finished because we found character", (char)c);
//					reader.reset();	//reset to the last mark, which was set right before the character we found
					finished=true;	//break out of the look, as we didn't recognize the next character
					break;		//assume we've parsed all of the resource
			}
			if(!finished)	//if we're not finished with the resource components
			{
Debug.trace("between components, ready to skip separators, with next character", (char)peek(reader));
				c=skipSeparators(reader);	//skip separators and peek the next character
Debug.trace("between components, read character", (char)c);
			}
			else	//if we have no more components to parse
			{
				break;	//breat out of the loop
			}
		}
		if(lastDescriptionComponent==null)	//if we didn't find any resource components
		{
			checkReaderEnd(c);	//make sure we're not at the end of the reader
			throw new ParseIOException("Expected resource; found character: "+(char)c);	//TODO improve with source throwable
		}
Debug.trace("ready to get resource proxy for label", label, "resource URI", CollectionUtilities.toString(resourceURIs, '.'));
		final ResourceProxy resourceProxy=getResourceProxy(label, resourceURIs.toArray(new URI[resourceURIs.size()]));	//get a resource proxy from the reference URI, or use one already available for the reference URI
Debug.trace("type count", types.size());
		if(!types.isEmpty())	//if we have at least one type
		{
			final Resource typePropertyResource=getResourceProxy(null, TYPE_PROPERTY_URI);	//get a proxy to the type property resource
			for(final Resource type:types)	//for each type
			{
				addAssertion(new Assertion(resourceProxy, typePropertyResource, type));	//assert this type
			}
		}
		if(lastDescriptionComponent==DescriptionComponent.PROPERTIES)	//if we should parse properties
		{
			parseProperties(reader, baseURI, resourceProxy);	//parse the resource properties
		}
		return resourceProxy;	//return the resource proxy we created
	}

	/**Checks that the description component can be changed to the new description component while parsing a resource description.
	This method ensures that description components come in the correct order and are not repeated.
	@param oldDescriptionComponent The last description component, or <code>null</code> if no description component has been parsed.
	@param newDescriptionComponent The new description component ready to be parsed.
	@return The new description component, if it is a valid component to parse in this context.
	@exception NullPointerException if the new description component is <code>null</code>.
	@exception ParseIOException if the given description component is being repeated or appears out of order.
	*/
	protected static DescriptionComponent checkDescriptionComponent(final DescriptionComponent oldDescriptionComponent, final DescriptionComponent newDescriptionComponent) throws ParseIOException
	{
		if(oldDescriptionComponent!=null && oldDescriptionComponent.ordinal()>=newDescriptionComponent.ordinal())	//if we've already reached or passed the old description component
		{
			throw new ParseIOException("Resource description component "+newDescriptionComponent+" cannot be repeated or appear out of order.");
		}
		return newDescriptionComponent;	//the new description component passed the tests; return it
	}


	/**Parses a list of resources.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the list of resources or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param end The character that marks the end of the list.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public Resource[] parseResourceList(final Reader reader, final URI baseURI, final char end) throws IOException, ParseIOException	//TODO del end if not needed
	{
//Debug.trace("ready to parse resource list for end", end);
		final List<Resource> resourceList=new ArrayList<Resource>();	//create a new list in which to place the resources
		int c=skipSeparators(reader);	//skip separators and peek the next character
Debug.trace("peeked", (char)c);
//TODO del if not needed		if(indexOf(RESOURCE_BEGINS, c)<0 && c!=LIST_DELIMITER)	//if this is not the beginning of a resource, return (but don't return for the list delimiter, which is an error
//TODO del		while(c>=0 &&)	//while we are not out of data
//TODO del if not needed		while(indexOf(RESOURCE_BEGINS, c)>=0)	//while there is another resource to parse
//TODO del		while(indexOf(RESOURCE_BEGINS, c)>=0)	//while there is another resource to parse
		while(c>=0 && c!=end)	//while the end of the data has not been reached and there is another resource to parse
		{
			final Resource resource=parseResource(reader, baseURI);	//parse another resource
Debug.trace("parsed resource from list", resource);
			resourceList.add(resource);	//parse another resource and add it to the list
			c=skipSeparators(reader);	//skip separators and peek the next character
Debug.trace("after resource, peeked", (char)c);
			if(c==LIST_DELIMITER)	//if this is a list delimiter
			{
				check(reader, LIST_DELIMITER);	//skip the list delimiter
				c=skipSeparators(reader);	//skip separators and peek the next character
			}
			else	//if there's anything besides a list delimiter, we've reached the end of the list
			{
				break;	//stop parsing the list
			}
		}
//Debug.trace("ready to return list of resources for end", end, "next character", (char)peek(reader));
		return resourceList.toArray(new Resource[resourceList.size()]);	//return the parsed resources
	}

	/**Parses a label surrounded by label delimiters.
	The current position must be that of the first label delimiter character.
	The new position will be that immediately after the last label delimiter character.
	@param reader The reader the contents of which to be parsed.
	@return The label parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current label is completely parsed.
	*/
	public String parseLabel(final Reader reader) throws IOException, ParseIOException
	{
		check(reader, LABEL_BEGIN);	//read the beginning label character
		final String label=reachAfter(reader, LABEL_END);	//read the label
		//TODO make sure this is a valid label
		return label;	//return the label we read
	}

	/**Parses a URI surrounded by URI delimiters.
	The current position must be that of the first URI delimiter character.
	The new position will be that immediately after the last URI delimiter character.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The label parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current URI is completely parsed.
	*/
	public URI parseURI(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		check(reader, URI_BEGIN);	//read the beginning URI character
		final URI localBaseURI;	//we'll store the local base URI, if there is one
		if(indexOf(URI_RESOURCE_BEGINS, peek(reader))>=0)	//if the URI begins with another URI
		{
			localBaseURI=asURI(parseResource(reader, baseURI));
		}
		else	//if the URI doesn't start with another URI
		{
			localBaseURI=null;	//there is no local base URI
		}
		final String uriString=reachAfter(reader, URI_END);	//read the rest of the URI
		try
		{
			URI uri=new URI(uriString);	//crate a URI from the string
			if(localBaseURI!=null)	//if we have a local base URI
			{
				uri=resolve(localBaseURI, uri);	//resolve the URI against the local base URI
			}
			if(baseURI!=null)	//if there is a base URI
			{
				uri=resolve(baseURI, uri);	//resolve the URI against the base URI				
			}
			return uri;	//return the resulting URI
		}
		catch(final URISyntaxException uriSyntaxException)	//one of the string was not a valid URI
		{
			throw new ParseIOException("Invalid URI: "+uriSyntaxException.getInput());
		}
	}

	/**Determines the URI represented by the given resource.
	@param resource The resource which is expected to represent a URI.
	@exception ParseIOException if the given resource has no URI or the URI does not represent a URI.
	*/
	protected static URI asURI(final Resource resource) throws ParseIOException
	{
		final URI resourceURI=resource.getURI();	//get the resource URI
		final String resourceURIFragment=resourceURI!=null && removeFragment(resourceURI).equals(URI_NAMESPACE_URI) ? resourceURI.getFragment() : null;	//get the fragment, if any
		if(resourceURIFragment!=null)	//if this is a URI resource fragment
		{
			try
			{
				return new URI(decode(resourceURIFragment));	//get the URI from the fragment TODO allow multiple resource URIs
			}
			catch(final URISyntaxException uriSyntaxException)	//if the fragment wasn't a valid URI
			{
				throw new ParseIOException("URI resource URI fragment "+resourceURIFragment+" not a valid URI");
			}
		}
		else	//if there is no fragment or this is not a URI namespace
		{
			throw new ParseIOException("Resource "+resource+" not a URI");
		}
	}

	/**Parses properties surrounded by property delimiters.
	The current position must be that of the first property delimiter character.
	The new position will be that immediately after the last property delimiter character.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param subject The resource to serve as the subject for the parsed properties.
	@exception NullPointerException if the given reader and/or subject resource is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current properties are completely parsed.
	*/
	public void parseProperties(final Reader reader, final URI baseURI, final Resource subject) throws IOException, ParseIOException
	{
		check(reader, PROPERTIES_BEGIN);	//read the beginning properties delimiter character
		int c=skipSeparators(reader);	//skip separators and peek the next character
		while(c!=PROPERTIES_END)	//while we haven't reached the end of the properties
		{			
			final Resource predicate=parseResource(reader, baseURI);	//parse the predicate resource
			skipSeparators(reader);	//skip separators
			final char propertyValueDelimiter=check(reader, PROPERTY_VALUE_DELIMITERS);	//read the next character and make sure it's a property-value delimiter
			Resource object;	//we'll use this to store one or more objects
			switch(skipSeparators(reader))	//skip separators and see what the next character will be
			{
				case ARRAY_BEGIN:	//array short form
						//TODO finish
					break;
				case SEQUENCE_BEGIN:	//sequence short form
						//TODO finish
					break;
				default:	//assume everything else is a normal resource object
					object=parseResource(reader, baseURI);	//parse the object
					switch(propertyValueDelimiter)	//see what sort of assignment this is
					{
						case PROPERTY_VALUE_DELIMITER:	//property assignment
							addAssertion(new Assertion(subject, predicate, object));	//assert the assertion
							break;
						case PROPERTY_VALUE_CONTEXT_DELIMITER:	//contextual property assignment
							//TODO finish
							break;
						default:
							throw new AssertionError("Unrecognized property-value delimiter: "+propertyValueDelimiter);	//we already checked this character, so we shouldn't get an unknown delimiter here
					}
			}
			c=skipSeparators(reader);	//skip separators and peek the next character
Debug.trace("after property-value pair, peeked", (char)c);
			if(c==LIST_DELIMITER)	//if this is a list delimiter
			{
				check(reader, LIST_DELIMITER);	//skip the list delimiter
				c=skipSeparators(reader);	//skip separators and peek the next character
			}
		}			
		check(reader, PROPERTIES_END);	//read the ending properties delimiter
	}

}