package com.garretwilson.urf;

import java.net.*;
import java.util.*;

import static java.util.Collections.*;

import static com.garretwilson.lang.ObjectUtilities.*;
import com.garretwilson.net.*;
import static com.garretwilson.net.URIUtilities.*;
import com.garretwilson.rdf.*;
import static com.garretwilson.rdf.RDFConstants.*;
import static com.garretwilson.rdf.RDFXMLConstants.*;
import com.garretwilson.text.xml.*;
import static com.garretwilson.text.xml.schema.XMLSchemaConstants.*;
import static com.garretwilson.urf.URF.*;
import static com.garretwilson.urf.dcmi.DCMI.LANGUAGE_PROPERTY_URI;
import com.garretwilson.util.*;
import static com.garretwilson.util.LocaleUtilities.*;

import org.w3c.dom.*;

/**Constructs an URF data instance from an RDF/XML representation.
The TURF processor maintains an internal URF data model throughout its lifetime that is continually updated with every new URF processing that occurs.
The TURF processor maintains TURF data in two separate formats: the URF data model, {@link URF}, as well as a list of assertions used to create the data model.
The URF data model may be replaced and its members modified, but these actions will not update the list of URF assertions.
The URF statements are only generated by the TURF processor itself as it parses RDF/XML, and are available to give information on the parser actions.
<p>Copyright © 2007 GlobalMentor, Inc.
This source code can be freely used for any purpose, as long as the following conditions are met.
Any object code derived from this source code must include the following text to users using along with other "about" notifications:
"Uniform Resource Framework (URF) <http://www.urf.name/> specification and processing
written by Garret Wilson <http://www.garretwilson.com/> and Copyright © 2007 GlobalMentor, Inc. <http://www.globalmentor.com/>."
Any redistribution of this source code or derived source code must include these comments unmodified.</p>
@author Garret Wilson
*/
public class URFRDFXMLProcessor extends AbstractURFProcessor
{

	/**The string form of the RDF namespace URI.*/
	final private String RDF_NAMESPACE_URI_STRING=RDF_NAMESPACE_URI.toString();

	/**Specifies a requirement for the presence of the RDF namespace in order for an RDF attribute to be recognized.
	@author Garret Wilson
	*/
	public enum NamespaceRequirement
	{
		/**Only the RDF namespace is accepted for an RDF attribute to be recognized.*/
		RDF,

		/**The RDF namespace or the <code>null</code> namespace is accepted for an RDF attribute.
		The <code>null</code> namespace is only accepted for attributes if the parent element is in the RDF namespace.
		*/
		RDF_OR_NULL,

		/**Any namespace is accepted for an RDF attribute.
		This is useful, for example, as a stop-gap measure for systems that corrupt attribute namespaces, such as Apache httpd 2.2.3 mod_dav.
		This setting is dangerous, however, as any RDF properties stored as attributes with the same local name as an RDF attribute (e.g. <code>about</code> and <code>first</code> are essentially ignored).
		*/
		ANY
	};

	/**Values for parsing attribute properties.
	@author Garret Wilson
	*/
	protected enum AttributePropertyContext
	{
		/**An attribute in the context of a resource description (<code>&lt;rdf:Description&gt;</code>).*/
		DESCRIPTION,
		/**An attribute in the context of a resource reference (<code>reference="&hellip;"</code>).*/
		REFERENCE,
		/**An attribute in the context of a property reference with only attributes and no children.*/
		EMPTY_PROPERTY,
		/**An attribute in the context of a reference short form (<code>parseType="Resource"</code>).*/
		PROPERTY_AND_NODE;
	}

	/**Whether and which namespace is required for an RDF attribute to be recognized as such.*/
	private NamespaceRequirement rdfAttributeNamespaceRequirement=NamespaceRequirement.RDF_OR_NULL;

		/**@return Whether and which namespace is required for an RDF attribute to be recognized as such.*/
		public NamespaceRequirement getRDFAttributeNamespaceRequirement() {return rdfAttributeNamespaceRequirement;}

		/**Sets whether and which namespace is required for an RDF attribute to be recognized as such.
		@param namespaceRequirement Whether and which namespace is required for an RDF attribute to be recognized as such.
		@exception NullPointerException if the given namespace requirement is <code>null</code>.
		*/
		public void setRDFAttributeNamespaceRequirement(final NamespaceRequirement namespaceRequirement) {this.rdfAttributeNamespaceRequirement=checkInstance(namespaceRequirement, "Namespace requirement cannot be null.");}

	/**Default constructor.*/
	public URFRDFXMLProcessor()
	{
		this(new URF());  //create an URF data model to use
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param urf The URF data model to use.
	*/
	public URFRDFXMLProcessor(final URF urf)
	{
		super(urf);  //construct the parent class
	}

	/**Processes RDF serialized in an XML document.
	Processes data contained in every <code>&lt;rdf:RDF&gt;</code> data island.
	@param document The XML document that might contain RDF data.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The URF data model resulting from this processing and any previous processing.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	public URF processRDF(final Document document, final URI baseURI) throws DataException
	{
		return processRDF(document.getDocumentElement(), baseURI); //process the data in the document
	}

	/**Processes RDF serialized in an XML document.
	Searches the given element and all its children, processing data contained in every <code>&lt;rdf:RDF&gt;</code> data island.
	@param element The XML element that might contain RDF data.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The URF data model resulting from this processing and any previous processing.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	public URF processRDF(final Element element, final URI baseURI) throws DataException
	{
		reset();	//make sure we don't have temporary data left over from last time
		try
		{
			processRDFIslands(element, baseURI);	//process any internal RDF islands
			createResources();	//create all proxied resources in the statements we gathered
			processAssertions();	//process the collected assertions
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if something was wrong with one of the resources
		{
			throw new DataException(illegalArgumentException);
		}
		reset();	//release all our references temporary resource proxies
		return getURF();  //return the URF data collected
	}

	/**Processes an RDF resource serialized in the provided XML document.
	Whatever base URI has been set is unchanged.
	@param element The XML element that might contain RDF data.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The URFdata model resulting from this processing and any previous processing.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	public URFResource processRDFResource(final Element element, final URI baseURI) throws DataException
	{
		reset();	//make sure we don't have temporary data left over from last time
		final URFResource urfResource;
		try
		{
			final Resource resource=processResource(element, baseURI);	//process the given RDF resource
			urfResource=createResources(resource);	//create all proxied resources in the statements we gathered, and get the URF resource the element represents
			processAssertions();	//process the collected assertions
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if something was wrong with one of the resources
		{
			throw new DataException(illegalArgumentException);
		}
		reset();	//release all our references temporary resource proxies
		return urfResource;  //return the URF resource the element represents
	}

	/**Processes RDF serialized in an XML document.
	Searches the given element and all its children, processing data contained in every <code>&lt;rdf:RDF&gt;</code> data island.
	@param element The XML element that might contain RDF data.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The URF data model resulting from this processing and any previous processing.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	protected URF processRDFIslands(final Element element, final URI baseURI) throws DataException
	{
		if(RDF_NAMESPACE_URI_STRING.equals(element.getNamespaceURI()) //if this element is in the RDF namespace
			  && ELEMENT_RDF.equals(element.getLocalName())) //if this element indicates that the children are RDF
		{
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					processResource((Element)childNode, baseURI);  //parse the contents of the RDF container element
				}
			}
		}
		else  //if this is a normal, non-RDF node
		{
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					processRDFIslands((Element)childNode, baseURI);  //parse the contents of the element, not knowing if this is an RDF element or not
				}
			}
		}
		return getURF();  //return the RDF data collected
	}

	/**Processes the given element as representing an RDF resource.
	@param element The XML element that represents the RDF resource.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return An object identifying the resource the XML element represents.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	protected Resource processResource(final Element element, final URI baseURI) throws DataException
	{
		final String elementLocalName=element.getLocalName(); //get the element's local name
		final URI elementNamespaceURI; //we'll determine the namespace URI from the element
		final String elementNamespaceString=element.getNamespaceURI();	//get the element's namespace string
		if(elementNamespaceString!=null)	//if there is a namespace string
		{
			try
			{
				elementNamespaceURI=new URI(elementNamespaceString); //create a URI from the namespace string
			}
			catch(final URISyntaxException uriSyntaxException)	//if the namespace URI was not syntactically correct
			{
				throw new DataException(uriSyntaxException);
			}
		}
		else	//if the element has no namespace
		{
			throw new DataException("Element "+elementLocalName+" has no namespace URI.");
		}
		final String resourceURIString=getRDFAttribute(element, ATTRIBUTE_ABOUT); //get the URI attribute value, if there is one
		final String nodeID=getRDFAttribute(element, ATTRIBUTE_NODE_ID);	//get the node ID attribute value, if there is one
		final String anchorID=getRDFAttribute(element, ATTRIBUTE_ID); //get the anchor ID if there is one
		if(resourceURIString!=null)	//if there is a URI
		{
			if(anchorID!=null)	//if there is also an anchor ID
			{
				throw new DataException("Resource cannot have both URI "+resourceURIString+" and anchor ID "+anchorID+".");
			}
			else if(nodeID!=null)	//if there is also a node ID
			{
				throw new DataException("Resource cannot have both URI "+resourceURIString+" and node ID "+nodeID+".");
			}
		}
		final URI resourceURI;  //we'll determine the URI from the rdf:about or rdf:ID attribute
		try
		{
			if(resourceURIString!=null) //if there is a URI
			{
				resourceURI=getResourceURI(resolveURI(element, baseURI, new URI(resourceURIString)));  //resolve the URI to the base URI and get an URF version of the URI
			}
			else if(anchorID!=null)  //if there is an anchor ID
			{
				resourceURI=getResourceURI(resolveFragment(XMLBase.getBaseURI(element, baseURI), anchorID));  //create a URI from the document base URI and the anchor ID and get an URF version of the URI
			}
			else  //if there is neither a resource ID nor an anchor ID
			{
				resourceURI=null;  //this is a blank node
			}
		}
		catch(final URISyntaxException uriSyntaxException)	//if a URI was not syntactically correct
		{
			throw new DataException(uriSyntaxException);
		}
		final Resource resource=determineResourceProxy(nodeID, resourceURI);	//get a resource proxy from the URI and/or node ID
		final URI typeURI;	//determine the URI of the shorthand type URI, if possible
		if(RDF_NAMESPACE_URI.equals(elementNamespaceURI) && ELEMENT_DESCRIPTION.equals(elementLocalName))	//if this is an <rdf:Description> element
		{
			typeURI=null;	//there is no type short form
		}
		else	//if this is not an <rdf:Description> element, the element name gives its type, so add that type to the resource
		{
			final Resource typePropertyResource=determineResourceProxy(TYPE_PROPERTY_URI);	//get a proxy to the type property resource
			typeURI=getResourceURI(RDFUtilities.createReferenceURI(elementNamespaceURI, elementLocalName));	//create a type URI and get the equivalent URF URI
			final Resource typePropertyValue=determineResourceProxy(typeURI);	//locate the resource representing the type value
			addAssertion(new Assertion(resource, typePropertyResource, typePropertyValue));	//assert this type
		}
		processAttributeProperties(resource, element, AttributePropertyContext.DESCRIPTION, baseURI);  //parse the attributes for the resource description
		processChildElementProperties(resource, typeURI, element, baseURI);	//parse the child elements as properties
		return resource;  //return the resource or resource proxy we created
	}

	/**Parses the child elements of the given element and assign them as properties to the given resource.
	@param resource The object that represents the resource to which child element properties should be added.
	@param typeURI The URI representing the type of the resource, if it is already known, or <code>null</code> if no type is known.
	@param element The element that contains the attributes to be considered properties.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	protected void processChildElementProperties(final Resource resource, final URI typeURI, final Element element, final URI baseURI) throws DataException
	{
		int memberCount=0; //show that we haven't found any container members, yet
		final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
		for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
		{
			final Node childNode=childNodeList.item(i); //get a reference to this child node
			if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
			{
				final Resource property=processProperty(resource, typeURI, (Element)childNode, memberCount, baseURI);  //parse the element representing an RDF property
				final URI propertyURI=property.getURI();	//get the property URI
				if(propertyURI!=null && isLexicalTypeURI(propertyURI, ORDINAL_CLASS_URI))	//if this is an ordinal property (originally serialized as rdf:li)
				{
					++memberCount;  //show that we have another member
				}
			}
		}
	}

	/**Parses the attributes of the given element and assign them as properties to the given resource.
	Each attribute property will be asserted.
	Special RDF properties such as <code>rdf:about</code> are ignored.
	@param resource The object that represents the resource to which attribute properties should be added.
	@param element The element that contains the attributes to be considered properties.
	@param context Whether the attributes are part of a resource description, a resource reference, a reference to a blank node resource in short form, or the creation of a blank node from an empty property element.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	protected void processAttributeProperties(final Resource resource, final Element element, final AttributePropertyContext context, final URI baseURI) throws DataException
	{
		try
		{
				//TODO make sure we make sure there is no reference or node ID attributes for AttributePropertyContext.EMPTY_PROPERTY
			final URI elementNamespaceURI; //we'll determine the namespace URI from the element
			final String elementNamespaceString=element.getNamespaceURI();	//get the element's namespace string
			if(elementNamespaceString!=null)	//if there is a namespace string
			{
				elementNamespaceURI=new URI(elementNamespaceString); //create a URI from the namespace string
			}
			else	//if the element has no namespace
			{
				throw new DataException("Element "+element.getLocalName()+" has no namespace URI.");
			}
			final NamedNodeMap attributeNodeMap=element.getAttributes();  //get a map of the attributes
			for(int i=attributeNodeMap.getLength()-1; i>=0; --i)  //look at each of the attributes
			{
				final Attr attribute=(Attr)attributeNodeMap.item(i);  //get a reference to this attribute

				final String attributeLocalName=attribute.getLocalName(); //get the attribute's local name
				final URI attributeNamespaceURI; //we'll determine the namespace URI from the attribute
				final String attributeNamespaceString=attribute.getNamespaceURI();	//get the attribute's namespace string
				if(attributeNamespaceString!=null)	//if there is a namespace string
				{
					attributeNamespaceURI=new URI(attributeNamespaceString); //create a URI from the namespace string
				}
				else	//if the attribute has no namespace
				{
					throw new DataException("Attribute "+attributeLocalName+" has no namespace URI.");
				}
				final String attributePrefix=attribute.getPrefix(); //get the attribute's prefix
			  final String attributeValue=attribute.getValue(); //get the attribute's value
					//ignore attributes with the "xmlns" prefix or in the xmlns namespace
				if(XMLConstants.XMLNS_NAMESPACE_PREFIX.equals(attributePrefix) || XMLConstants.XMLNS_NAMESPACE_URI.equals(attributeNamespaceURI))
				{
					continue;
				}
					//process attributes with the "xml" prefix (or in the xml namespace) specially
				else if(XMLConstants.XML_NAMESPACE_PREFIX.equals(attributePrefix) || XMLConstants.XML_NAMESPACE_URI.equals(attributeNamespaceURI))
				{
						//TODO add support for xml:lang
					continue;
				}
				  //ignore the rdf:about attribute in descriptions, disallow it in references
				else if(isRDFAttribute(ATTRIBUTE_ABOUT, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
				{
					switch(context)	//only allow this attribute in certain contexts
					{
						case REFERENCE:	//rdf:about isn't allowed in a reference
						case EMPTY_PROPERTY:	//rdf:about isn't allowed in an empty property element
						case PROPERTY_AND_NODE: 	//rdf:about isn't allowed in parseType="Resource"
							throw new DataException("rdf:about attribute is not allowed in a resource reference.");
						case DESCRIPTION:	//ignore rdf:about in descriptions
						default:
							continue;
					}
				}
				  //ignore the rdf:ID attribute in descriptions, disallow it in references
				else if(isRDFAttribute(ATTRIBUTE_ID, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
				{
					switch(context)	//only allow this attribute in certain contexts
					{
						case REFERENCE:	//rdf:ID isn't allowed in a reference
						case EMPTY_PROPERTY:	//rdf:ID isn't allowed in an empty property element
						case PROPERTY_AND_NODE: 	//rdf:ID isn't allowed in parseType="Resource"
							throw new DataException("rdf:ID attribute is not allowed in a resource reference.");
						case DESCRIPTION:	//ignore rdf:ID in descriptions
						default:
							continue;
					}
				}
					//ignore the rdf:nodeID attribute in descriptions and references
				else if(isRDFAttribute(ATTRIBUTE_NODE_ID, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
				{
					switch(context)	//only allow this attribute in certain contexts
					{
						case PROPERTY_AND_NODE: 	//rdf:nodeID isn't allowed in parseType="Resource" TODO make sure this is correct
							throw new DataException("rdf:nodeID attribute is not allowed in blank node reference short form.");
						case REFERENCE:	//ignore rdf:nodeID in references
						case EMPTY_PROPERTY:	//ignore rdf:nodeID in empty property elements TODO make sure this is correct
						case DESCRIPTION:	//ignore rdf:nodeID in descriptions
						default:
							continue;
					}
				}
				  //ignore the rdf:parseType attribute in references, disallow it in descriptions
				else if(isRDFAttribute(ATTRIBUTE_PARSE_TYPE, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
				{
					switch(context)	//only allow this attribute in certain contexts
					{
						case DESCRIPTION:	//rdf:parseType isn't allowed in a description
						case REFERENCE:	//rdf:parseType isn't allowed in references
						case EMPTY_PROPERTY:	//rdf:parseType isn't allowed in an empty property element
							throw new DataException("rdf:parseType attribute is not allowed in a resource description.");
						case PROPERTY_AND_NODE: 	//ignore rdf:parseType in the property-and-node context (that's the attribute that defined this context, after all)
						default:
							continue;
					}
				}
				  //ignore the rdf:resource attribute in reference, disallow it in descriptions
				else if(isRDFAttribute(ATTRIBUTE_RESOURCE, elementNamespaceURI, attributeNamespaceURI, attributeLocalName))
				{
					switch(context)	//only allow this attribute in certain contexts
					{
						case DESCRIPTION:	//rdf:resource isn't allowed in descriptions
						case EMPTY_PROPERTY:	//rdf:resource isn't allowed in an empty property element
						case PROPERTY_AND_NODE: 	//rdf:ID isn't allowed in parseType="Resource"
							throw new DataException("rdf:resource attribute is not allowed in a resource reference.");
						case REFERENCE:	//rdf:resource isn't allowed in a reference
						default:
							continue;
					}
				}
				else	//for all other attributes
				{
					switch(context)	//only allow this attribute in certain contexts
					{
						case REFERENCE:	//normal attributes are allowed for a normal reference
						case PROPERTY_AND_NODE: 	//normal attributes isn't allowed in the parseType="Resource" context
							throw new DataException(attribute.getName()+" attribute is not allowed in a property-and-node context.");
						default:
							{
								final URI propertyURI=getResourceURI(RDFUtilities.createReferenceURI(attributeNamespaceURI, attributeLocalName));	//get the URF equivalent of the property URI
								final Resource property=determineResourceProxy(propertyURI);	//locate a resource proxy for this attribute property
								final Resource object=determineResourceProxy(createStringURI(attributeValue));	//create a string for the object
								addAssertion(new Assertion(resource, property, object));	//assert this property
							}
							break;
					}
				}
			}
		}
		catch(final URISyntaxException uriSyntaxException)	//if a URI was not syntactically correct
		{
			throw new DataException(uriSyntaxException);
		}
	}

	/**Processes the given element as representing an RDF property.
	The property and value(s) will be asserted for the given resource.
	@param resource The resource to which the property should be added.
	@param typeURI The URI representing the type of the resource, if it is already known, or <code>null</code> if no type is known.
	@param element The XML element that represents the RDF property.
	@param memberCount The number of container member items (represented by <code>rdf:li</code>) the resource already contains.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The resource that represents the processed property, the predicate of the added statement.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	public Resource processProperty(final Resource resource, final URI typeURI, final Element element, final int memberCount, final URI baseURI) throws DataException
	{
		final String elementLocalName=element.getLocalName(); //get the element's local name
		final URI elementNamespaceURI; //we'll determine the namespace URI from the element
		final String elementNamespaceString=element.getNamespaceURI();	//get the element's namespace string
		if(elementNamespaceString!=null)	//if there is a namespace string
		{
			try
			{
				elementNamespaceURI=new URI(elementNamespaceString); //create a URI from the namespace string
			}
			catch(final URISyntaxException uriSyntaxException)	//if the namespace URI was not syntactically correct
			{
				throw new DataException(uriSyntaxException);
			}
		}
		else	//if the element has no namespace
		{
			throw new DataException("Element "+elementLocalName+" has no namespace URI.");
		}
		final URI propertyURI;	//if this is an rdf:li property, we'll convert it to an URF ordinal resource using the member count plus one as the ordinal
		if(RDF_NAMESPACE_URI.equals(elementNamespaceURI) && LI_PROPERTY_NAME.equals(elementLocalName)) //if this is an rdf:li property
		{
			if(SET_CLASS_URI.equals(typeURI))	//if this is a set
			{
				propertyURI=ELEMENT_PROPERTY_URI;	//use the urf.element property
			}
			else	//if this is some other container type
			{
				propertyURI=createOrdinalURI(memberCount+1); //create an ordinal of the member count plus one
			}
		}
		else	//if this is *not* an rdf:li property, it's a normal property
		{
			propertyURI=getResourceURI(RDFUtilities.createReferenceURI(elementNamespaceURI, elementLocalName));	//use the element's local name normally in forming the property URI, and get the URF equivalent of the URI
		}
		final Resource propertyResource=determineResourceProxy(propertyURI);	//get a proxy to the property resource
		final Resource propertyValue;  //we'll assign the property value to this variable
		final String parseType=getRDFAttribute(element, ATTRIBUTE_PARSE_TYPE); //get the parse type, if there is one
		if(COLLECTION_PARSE_TYPE.equals(parseType))	//if this is a collection
		{
			//TODO make sure there are no other attributes
			propertyValue=createResourceProxy();	//the property value will be an anonymous list
			final Resource typePropertyResource=determineResourceProxy(TYPE_PROPERTY_URI);	//get a proxy to the type property resource
			final Resource listType=determineResourceProxy(LIST_CLASS_URI);	//get a proxy to the list type
			addAssertion(new Assertion(propertyValue, typePropertyResource, listType));	//assert the list type on the list
				//parse the child elements
			int elementIndex=0;	//keep track of the list element index, which doesn't necessarily correspond with the XML child node index
			final NodeList childNodeList=element.getChildNodes(); //get a list of child nodes
			for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
			{
				final Node childNode=childNodeList.item(i); //get a reference to this child node
				if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
				{
					final Resource elementValue=processResource((Element)childNode, baseURI); //process the child element as an RDF resource
					final Resource indexPredicate=determineResourceProxy(createOrdinalURI(elementIndex++));	//get the ordinal property for specifying the index of each value, and go to the next element index
					addAssertion(new Assertion(propertyValue, indexPredicate, elementValue));	//assert the assertion that the element is an index of the list
				}
			}
		}
		else if(RESOURCE_PARSE_TYPE.equals(parseType))	//if this is a resource as a property-and-node
		{
			propertyValue=createResourceProxy();	//retrieve or create a new resource proxy for an anonymous node
			processAttributeProperties(propertyValue, element, AttributePropertyContext.PROPERTY_AND_NODE, baseURI);  //parse the property attributes, which will simply create errors if there are any unexpected attributes
			processChildElementProperties(propertyValue, null, element, baseURI);	//parse the child elements as properties; there is no type short form
		}
		else if(LITERAL_PARSE_TYPE.equals(parseType))	//if this is an XMLLiteral
		{
			throw new UnsupportedOperationException("XMLLiteral not yet supported in URF");
/*TODO fix
			//TODO process the attributes to make sure there are no unexpected attributes
			final Document document=XMLUtilities.createDocument(element);	//create a new document from a copy of the given element
			//G***do we want to ensure namespace declarations?
			final Element documentElement=document.getDocumentElement();	//get a reference to the document element
			final DocumentFragment documentFragment=XMLUtilities.extractChildren(documentElement);	//extract the children of the document element to a document fragment TODO important probably reset the owner document, so that this won't keep the entire original document tree around
			propertyValue=new RDFXMLLiteral(documentFragment);	//create an XML literal containing the document fragment, which now contains a copy of the information of the XML tree below the given element
*/
		}
		else	//by default assume that we're parsing a resource as the property value
		{
			final String resourceURIString=getRDFAttribute(element, ATTRIBUTE_RESOURCE); //get the URI of the referenced resource, if there is one
			final String nodeID=getRDFAttribute(element, ATTRIBUTE_NODE_ID);	//get the node ID attribute value, if there is one
			if(resourceURIString!=null && nodeID!=null)	//if both a URI and a node ID were given
			{
				throw new DataException("Resource cannot have both URI "+resourceURIString+" and node ID "+nodeID+".");
			}
			if(resourceURIString!=null || nodeID!=null) //if there is a URI or a node ID, this is a reference to another node
			{
				try
				{
					final URI resourceURI=resourceURIString!=null ? getResourceURI(resolveURI(element, baseURI, new URI(resourceURIString))) : null;  //if there is a URI, resolve it to the base URI and get the URF equivalent
					propertyValue=determineResourceProxy(nodeID, resourceURI);	//retrieve or create a resource proxy from the node ID and/or URI
					processAttributeProperties(propertyValue, element, AttributePropertyContext.REFERENCE, baseURI);  //parse the property attributes, assigning them to the property value
				}
				catch(final URISyntaxException uriSyntaxException)	//if a URI was not syntactically correct
				{
					throw new DataException(uriSyntaxException);
				}
			}
			else if(element.getChildNodes().getLength()==0 && element.getAttributes().getLength()!=0) //if there are no child elements but there are attributes, this is a blank node
			{
				propertyValue=createResourceProxy();	//create a new anonymous resource proxy
				processAttributeProperties(propertyValue, element, AttributePropertyContext.EMPTY_PROPERTY, baseURI);  //parse the property attributes, assigning them to the property value
			}
			else  //if there is no URI or node ID, and there are children, there is either a normal property description below, or a literal
			{
					//TODO make sure there are no attributes
				propertyValue=processPropertyValueContents(resource, propertyResource, element, baseURI);	//process the contents of the element as a normal property value
			}
		}
		addAssertion(new Assertion(resource, propertyResource, propertyValue));	//assert this property
		return propertyResource;	//return the resource that represents the property we processed
	}

	/**Processes the contents of a property element as normal property contents.
	Nodes that are not elements are not capable of determining RDF typed literal datatypes and language tags
	This method does not actually assert the property value, although it may assert a scoped subproperty value.
	@param resource The resource to which the property should be added.
	@param propertyResource The resource which indicates the predicate for the value to be processed.
	@param propertyNode The node the contents of which represents the property value.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The resource representing the property value.
	@exception DataException Thrown if there was an error processing the RDF/XML.
	*/
	public Resource processPropertyValueContents(final Resource resource, final Resource propertyResource, final Node propertyNode, final URI baseURI) throws DataException
	{
		Element childElement=null; //show that we haven't found any child elements, yet
			//parse the child elements
		final NodeList childNodeList=propertyNode.getChildNodes(); //get a list of child nodes
		for(int i=0; i<childNodeList.getLength(); ++i)  //look at each child node
		{
			final Node childNode=childNodeList.item(i); //get a reference to this child node
			if(childNode.getNodeType()==Node.ELEMENT_NODE) //if this is an element
			{
				if(childElement==null)  //if we haven't already found a child element
				{
					childElement=(Element)childNode;  //cast the child node to an element
				}
				else if(childElement!=null)  //if we've already found a child element
				{
					throw new DataException("Only one property value allowed for property element "+propertyNode.getNodeName());
				}
			}
		}
		if(childElement!=null)  //if we found a child element for the property value
		{
			return processResource(childElement, baseURI); //process the child element as an RDF resource, the value of the property in this case
		}
		else  //if we didn't find any child elements, the content is a literal
		{
			final String childText=XMLUtilities.getText(propertyNode, true);	//retrieve the child text
			final String datatype=propertyNode instanceof Element ? getRDFAttribute((Element)propertyNode, ATTRIBUTE_DATATYPE) : null; //get the datatype, if there is one TODO check elsewhere to make sure a datatype isn't given for non-literal content
			final URI lexicalTypeURI;	//all RDF literals belong in some URF lexical namespace; determine the type URI
			String languageTag=null;		//there may be a language tag for RDF plain literals
			if(datatype!=null)	//if a datatype is present
			{
				try
				{
					lexicalTypeURI=getURFLexicalTypeURI(new URI(datatype));	//find the URF lexical type URI from the datatype URI
				}
				catch(final URISyntaxException uriSyntaxException)	//if the datatype string is not a valid URI
				{
					throw new DataException(uriSyntaxException);
				}
			}
			else	//if a datatype is not present, this is a plain literal
			{
				lexicalTypeURI=STRING_CLASS_URI;	//RDF plain literals are strings
					//get the xml:lang language tag, if there is one
				languageTag=propertyNode instanceof Element ? XMLUtilities.getDefinedAttributeNS((Element)propertyNode, XMLConstants.XML_NAMESPACE_URI.toString(), XMLConstants.ATTRIBUTE_LANG) : null;
			}
			final URI valueURI=createLexicalURI(lexicalTypeURI, childText);	//create a URI for the value
			final Resource valueResource=determineResourceProxy(valueURI);	//determine the value resource from the value URI
			if(languageTag!=null)	//if a language tag was given
			{
				final Locale locale=createLocale(languageTag);	//create a locale from the language tag
				final NameValuePair<Resource, Resource>[] scopeChain=new NameValuePair[]{new NameValuePair<Resource, Resource>(propertyResource, valueResource)};	//create a scope chain consisting of the property literal value assignment
				final Resource languagePropertyResource=determineResourceProxy(LANGUAGE_PROPERTY_URI);	//get a proxy to the dc.language property resource
				final Resource languageValueResource=determineResourceProxy(createInfoLangURI(locale));	//get a resource proxy for the language value
				addAssertion(new Assertion(resource, languagePropertyResource, languageValueResource, scopeChain));	//assert the language tag within this property's scope
			}
			return valueResource;	//return the value we calculated
		}
	}

	/**Determines if an element attribute is an RDF attribute, recognizing either prefixed or non-prefixed attributes.
	@param rdfAttributeLocalName The RDF attribute name to check for.
	@param elementNamespaceURI The namespace of the element to which the attribute belongs.
	@param attributeNamespaceURI namespace of the RDF attribute.
	@param attributeLocalName The local name of the RDF attribute.
	@return <code>true</code> if this is the specified RDF attribute.
	*/
	protected boolean isRDFAttribute(final String rdfAttributeLocalName, final URI elementNamespaceURI, final URI attributeNamespaceURI, final String attributeLocalName)
	{
		if(rdfAttributeLocalName.equals(attributeLocalName))	//if the attribute has the correct local name
		{
			if(RDF_NAMESPACE_URI.equals(attributeNamespaceURI))	//if the attribute is in the RDF namespace
			{
				return true;	//show that this is the expected RDF attribute
			}
			switch(getRDFAttributeNamespaceRequirement())	//see if the RDF attribute namespace is required
			{
				case RDF_OR_NULL:
					 if(attributeNamespaceURI==null && RDF_NAMESPACE_URI.equals(elementNamespaceURI))	//accept the null namespace if the element is in the RDF namespace
					 {
						 return true;
					 }
					 break;
				case ANY:
					return true;	//the namespace doesn't matter
			}
		}
		return false;	//show that this attribute is not the RDF attribute expected
	}

	/**Retrieves an RDF attribute from an element, if it exists, recognizing either prefixed or non-prefixed attributes. If the non-prefixed form is used, a warning is generated.
	It is assumed that this method will only be called once for a particular attribute, as each call could produce another warning.
	@param element The element being checked for attributes.
	@param attributeLocalName The local name of the RDF attribute to check for.
	@return The specified RDF attribute, or <code>null</code> if no such attribute was found.
	*/
	protected String getRDFAttribute(final Element element, final String attributeLocalName)
	{
		if(element.hasAttributeNS(RDF_NAMESPACE_URI_STRING, attributeLocalName))  //if there is a prefixed attribute value
		{
		  return element.hasAttributeNS(RDF_NAMESPACE_URI_STRING, attributeLocalName) ? element.getAttributeNS(RDF_NAMESPACE_URI_STRING, attributeLocalName) : null; //get the prefixed attribute value
		}
		switch(getRDFAttributeNamespaceRequirement())	//see if the RDF attribute namespace is required
		{
			case RDF_OR_NULL:
				if(RDF_NAMESPACE_URI.toString().equals(element.getNamespaceURI()) && element.hasAttributeNS(null, attributeLocalName)) //if there is a non-prefixed attribute value
				{
					Debug.warn("Non-prefixed rdf:"+attributeLocalName+" attribute deprecated.");
				  return element.hasAttributeNS(null, attributeLocalName) ? element.getAttributeNS(null, attributeLocalName) : null; //get the non-prefixed attribute value
				}
			case ANY:
				final NamedNodeMap attributes=element.getAttributes();	//get the attributes
				for(int i=attributes.getLength()-1; i>=0; --i)	//look at all the attributes
				{
					final Node attribute=attributes.item(i);	//get this attribute
					if(attributeLocalName.equals(attribute.getLocalName()))	//if this attribute has the correct local name
					{
						return attribute.getNodeValue();	//return the value of the attribute
					}
				}
				break;
		}
		return null;  //show that the RDF attribute is not available
	}


	/**The map of URF resource URIs keyed to RDF resource URIs.*/
	private final static Map<URI, URI> rdfResourceURIURFURFResourceURIMap;

	static
	{
		final Map<URI, URI> tempRDFResourceURIURFResourceURIMap=new HashMap<URI, URI>();	//create a new map
		tempRDFResourceURIURFResourceURIMap.put(ALT_PROPERTY_REFERENCE_URI, SET_CLASS_URI);	//fill the  map
		tempRDFResourceURIURFResourceURIMap.put(BAG_PROPERTY_REFERENCE_URI, LIST_CLASS_URI);
		tempRDFResourceURIURFResourceURIMap.put(LIST_PROPERTY_REFERENCE_URI, LIST_CLASS_URI);
		tempRDFResourceURIURFResourceURIMap.put(SEQ_PROPERTY_REFERENCE_URI, LIST_CLASS_URI);
		tempRDFResourceURIURFResourceURIMap.put(TYPE_PROPERTY_REFERENCE_URI, TYPE_PROPERTY_URI);
		rdfResourceURIURFURFResourceURIMap=unmodifiableMap(tempRDFResourceURIURFResourceURIMap);
	}

	/**Determines an URF resource URI from the given URF resource URI.
	The following conversions are made:
	<dl>
		<dt>{@value RDFConstants#ALT_PROPERTY_REFERENCE_URI}</dt> <dd>{@value URF#SET_CLASS_URI}</dd>
		<dt>{@value RDFConstants#BAG_PROPERTY_REFERENCE_URI}</dt> <dd>{@value URF#LIST_CLASS_URI}</dd>
		<dt>{@value RDFConstants#LIST_PROPERTY_REFERENCE_URI}</dt> <dd>{@value URF#LIST_CLASS_URI}</dd>
		<dt>{@value RDFConstants#SEQ_PROPERTY_REFERENCE_URI}</dt> <dd>{@value URF#LIST_CLASS_URI}</dd>
		<dt>{@value RDFConstants#TYPE_PROPERTY_REFERENCE_URI}</dt> <dd>{@value URF#TYPE_CLASS_URI}</dd>
	</dl>
	All other resource URIs are returned unchanged.
	@param rdfResourceURI The RDF resource URI.
	@return The URF resource URI to use in place of the given RDF resource URI.
	*/
	public static URI getResourceURI(final URI rdfResourceURI)
	{
		URI resourceURI=rdfResourceURIURFURFResourceURIMap.get(rdfResourceURI);	//see if we know an equivalent URF resource URI
		return resourceURI!=null ? resourceURI : rdfResourceURI;	//if we don't know an equivalent URF resource URI, just return the RDF resource URI
	}

	/**The map of URF lexical types keyed to RDF datatype URIs.*/
	private final static Map<URI, URI> datatypeURILexicalTypeURIMap;

	static
	{
		final Map<URI, URI> tempDatatypeURILexicalTypeURIMap=new HashMap<URI, URI>();	//create a new map
		tempDatatypeURILexicalTypeURIMap.put(BASE64_BINARY_DATATYPE_URI, BINARY_CLASS_URI);	//fill the  map
		tempDatatypeURILexicalTypeURIMap.put(BOOLEAN_DATATYPE_URI, BOOLEAN_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(BYTE_DATATYPE_URI, INTEGER_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(DATE_DATATYPE_URI, DATE_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(DATE_TIME_DATATYPE_URI, DATE_TIME_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(DECIMAL_DATATYPE_URI, REAL_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(DOUBLE_DATATYPE_URI, REAL_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(DURATION_DATATYPE_URI, DURATION_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(FLOAT_DATATYPE_URI, REAL_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(INT_DATATYPE_URI, INTEGER_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(INTEGER_DATATYPE_URI, INTEGER_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(LONG_DATATYPE_URI, INTEGER_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(SHORT_DATATYPE_URI, INTEGER_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(STRING_DATATYPE_URI, STRING_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(TIME_DATATYPE_URI, TIME_CLASS_URI);
		tempDatatypeURILexicalTypeURIMap.put(URI_DATATYPE_URI, URI_CLASS_URI);
		datatypeURILexicalTypeURIMap=unmodifiableMap(tempDatatypeURILexicalTypeURIMap);
	}

	/**Determines an URF lexical type URI from the given RDF datatype URI.
	The following conversions are made:
	<dl>
		<dt>{@value XMLSchemaContants#BASE64_BINARY_DATATYPE_URI}</dt> <dd>{@value URF#BINARY_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#BOOLEAN_DATATYPE_URI}</dt> <dd>{@value URF#BOOLEAN_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#BYTE_DATATYPE_URI}</dt> <dd>{@value URF#INTEGER_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#DATE_DATATYPE_URI}</dt> <dd>{@value URF#DATE_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#DATE_TIME_DATATYPE_URI}</dt> <dd>{@value URF#DATE_TIME_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#DECIMAL_DATATYPE_URI}</dt> <dd>{@value URF#REAL_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#DOUBLE_DATATYPE_URI}</dt> <dd>{@value URF#REAL_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#DURATION_DATATYPE_URI}</dt> <dd>{@value URF#DURATION_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#FLOAT_DATATYPE_URI}</dt> <dd>{@value URF#REAL_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#INT_DATATYPE_URI}</dt> <dd>{@value URF#INTEGER_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#INTEGER_DATATYPE_URI}</dt> <dd>{@value URF#INTEGER_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#LONG_DATATYPE_URI}</dt> <dd>{@value URF#INTEGER_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#SHORT_DATATYPE_URI}</dt> <dd>{@value URF#INTEGER_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#TIME_DATATYPE_URI}</dt> <dd>{@value URF#TIME_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#STRING_DATATYPE_URI}</dt> <dd>{@value URF#STRING_CLASS_URI}</dd>
		<dt>{@value XMLSchemaContants#URI_DATATYPE_URI}</dt> <dd>{@value URF#URI_CLASS_URI}</dd>
	</dl>
	All other datatype URIs are returned unchanged.
	@param rdfDatatypeURI The RDF datatype URI.
	@return The URF lexical type URI to use in place of the given RDF datatype URI.
	*/
	public static URI getURFLexicalTypeURI(final URI rdfDatatypeURI)
	{
		URI lexicalTypeURI=datatypeURILexicalTypeURIMap.get(rdfDatatypeURI);	//see if we know an equivalent URF lexical type URI
		return lexicalTypeURI!=null ? lexicalTypeURI : rdfDatatypeURI;	//if we don't know an equivalent URF lexical type URI, just return the RDF datatype URI
	}

	/**Creates a URI by resolving the given URI relative to the base URI of the provided element, taking into account the given base URI of the document.
	URIs are resolved according to RDF/XML processing rules.
	@param element The element for which a base URI should be determined.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param uri The URI to resolve.
	@return A URI resolved to the in-scope base URI of the given element.
	@exception NullPointerException if the given element and/or URI is <code>null</code>.
	@exception URISyntaxException Thrown if the constructed URI is invalid.
	@see XBase
	@see #resolveURI(URI, URI)
	*/
	protected static URI resolveURI(final Element element, URI baseURI, final URI uri) throws URISyntaxException
	{
		baseURI=XMLBase.getBaseURI(element, baseURI);  //get the base URI of the element
		return baseURI!=null ? resolveURI(baseURI, uri) : uri;	//resolve the given URI to the base URI we determine
	}

	/**Resolves a URI against a base URI according to RDF/XML processing rules.
	Significantly, the emptry string is appended to the given base URI.
	@param baseURI The in-scope base URI against which the URI should be resolved.
	@param uri The URI to resolve.
	@return A URI resolved to the given base URI according to RDF/XML processing rules.
	@exception NullPointerException if the given element and/or URI is <code>null</code>.
	@see <a href="http://www.w3.org/TR/2003/PR-rdf-syntax-grammar-20031215/#section-baseURIs">RDF/XML Syntax Specification (Revised) 5.3 Resolving URIs</a>
	 */
	public static URI resolveURI(final URI baseURI, final URI uri)
	{
		checkInstance(baseURI, "Base URI cannot be null.");
		if(isPathURI(uri))	//if the given URI is only a path
		{
			final String path=uri.getPath();	//get the path of the URI
			if(path.length()==0)	//if this URI is ""
			{
				return baseURI;	//return the base URI
			}
		}
		return baseURI.resolve(uri);	//resolve the URI against the base URI normally
	}

}