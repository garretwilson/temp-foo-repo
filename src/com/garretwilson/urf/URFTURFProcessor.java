package com.garretwilson.urf;

import java.io.*;
import java.math.*;
import java.net.*;
import java.util.*;
import static java.util.Collections.*;

import static com.garretwilson.io.ReaderParser.*;
import com.garretwilson.io.ParseIOException;
import com.garretwilson.net.*;
import static com.garretwilson.net.URIUtilities.*;
import static com.garretwilson.text.CharacterEncodingConstants.*;
import static com.garretwilson.text.CharacterConstants.*;
import static com.garretwilson.urf.URF.*;
import static com.garretwilson.urf.TURF.*;
import com.garretwilson.util.*;

/**Constructs an URF data instance from a TURF representation.
The TURF processor maintains an internal URF DF data model throughout its lifetime that is continually updated with every new URF processing that occurs.
The TURF processor maintains TURF data in two separate formats: the URF data model, {@link URF}, as well as a list of assertions used to create the data model.
The URF data model may be replaced and its members modified, but these actions will not update the list of URF assertions.
The URF statements are only generated by the TURF processor itself as it parses TURF, and are available to give information on the parser actions.
@author Garret Wilson
*/
public class URFTURFProcessor extends AbstractURFProcessor
{

	/**Default constructor.*/
	public URFTURFProcessor()
	{
		this(new URF());  //create an URF data model to use
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param urf The RDF data model to use.
	*/
	public URFTURFProcessor(final URF urf)
	{
		super(urf);  //construct the parent class
	}

	/**Parses all resources and then processes the resulting URF instance.
	The new position will be the end of the reader; any data appearing after the resources are considered syntax errors.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The URF data model.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public URF process(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		skipSeparators(reader);	//skip separators
		processResources(reader, baseURI);	//process resources
		checkReaderEnd(reader);	//make sure we're at the end of data
		return getURF();	//return the URF data model
	}

	/**Parses a list of resources resources and then processes the resulting URF instance.
	The current position must that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The URF data model.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public URF processResources(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		final Resource[] resources=parseResourceList(reader, baseURI, NULL_CHAR);	//parse as list of resources
/*TODO del
for(final Assertion assertion:getAssertions())	//look at the assertions
{
	Debug.trace("assertion:", assertion);
}
*/
		final URFResource resource=createResources(resources.length>0 ? resources[resources.length-1] : null);	//create all resources
		processAssertions();	//process the collected assertions
/*TODO del
for(final Assertion assertion:getAssertions())	//look at the assertions
{
	Debug.trace("assertion:", assertion);
}
*/
		return getURF();	//return the URF data model
	}

	/**Skips over TURF separators in a reader.
	This method skips all separator characters {@link TURF#SEPARATORS}, as well as any comments.
	The new position will either be the that of the first non-separator character or the end of the input stream.
	@param reader The reader the contents of which to be parsed.
	@return The next character that will be returned the reader's {@link Reader#read()} operation, or <code>-1</code> if the end of the reader has been reached.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	*/
	protected static int skipSeparators(final Reader reader) throws IOException
	{
		int c;	//we'll store the next non-separator character here so that it can be returned
		while((c=skip(reader, SEPARATORS))==COMMENT_BEGIN)	//skip all separators; if the start of a comment was encountered
		{
			check(reader, COMMENT_END);	//read the beginning comment delimiter
			pass(reader, COMMENT_END);	//skip past the end of the comment; we'll then skip all separator characters and see if another comment starts
		}
		return c;	//return the last character read
	}

	/**Parses a single resource and returns a proxy to the resource.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resources or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	*/
	public Resource parseResource(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		return parseResource(reader, baseURI, null, null, null, null);	//parse a resource with no scope or context URI
	}

	/**Parses a single optionally scoped resource and returns a proxy to the resource.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resources or the end of the reader.
	For every resource that is being parsed as the object of a subject and predicate, the scope base, scope chain, and scope predicate must all be non-<code>null</code>.
	Whenever the scope chain is lengthened it must first be cloned so that the local version will not be modified during recursion. 
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param scopeBase The base resource of the current scope, or <code>null</code> if the current resource is not in an object context.
	@param scopeChain The chain of scope, each element representing a property and value to serve as scope for the subsequent property and value, or <code>null</code> if there is no current scope.
	@param scopePredicate The predicate for which the new resource is a value, or <code>null</code> if the current resource is not in an object context.
	@param contextURI The URI serving as contexts in case the default namespace need to be determined, or <code>null</code> if there is no context; for properties, this is the URI of the first type short form; for objects, this is the URI of the predicate resource.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	*/
	protected Resource parseResource(final Reader reader, final URI baseURI, final Resource scopeBase, final ArrayList<NameValuePair<Resource, Resource>> scopeChain, final Resource scopePredicate, final URI contextURI) throws IOException, ParseIOException
	{
//Debug.trace("ready to parse resource");
		final URF urf=getURF();	//get the URF data model
		String label=null;	//the label of the resource, if any
		URI resourceURI=null;	//the URI of the resource, if any
		final List<Resource> types=new ArrayList<Resource>();	//the types, if any
//TODO del if not needed		Resource[] arrayElements=null;	//if we find an array, we'll store the elements here so that we can add them to the resource later
		boolean foundComponent=false;	//we'll keep track of whether at least one description component was present
		int c=peek(reader);	//peek the next character
		if(c==LABEL_BEGIN)	//check for a label
		{
//Debug.trace("ready to parse label");
			foundComponent=true;	//indicate that at least one description component is present
			label=parseLabel(reader);	//parse the label
//Debug.trace("label:", label);
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		switch(c)	//check for a reference or a short form
		{
			case REFERENCE_BEGIN:
//Debug.trace("found reference beginning");
				foundComponent=true;	//indicate that at least one description component is present
				resourceURI=parseURI(reader, baseURI, REFERENCE_BEGIN, REFERENCE_END);	//parse the resource URI
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case BINARY_BEGIN:	//binary
				foundComponent=true;	//indicate that at least one description component is present
				final byte[] binary=parseBinary(reader);	//parse the binary data
				resourceURI=createBinaryURI(binary);	//create a URI for the resource
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case BOOLEAN_BEGIN:	//boolean
				foundComponent=true;	//indicate that at least one description component is present
				final boolean b=parseBoolean(reader);	//parse the boolean
				resourceURI=createLexicalURI(BOOLEAN_CLASS_URI, Boolean.toString(b));	//create a URI for the resource
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case NUMBER_BEGIN:	//number
				foundComponent=true;	//indicate that at least one description component is present
				final Number number=parseNumber(reader, NUMBER_BEGIN, true, true, true);	//parse the number, allowing negative, decimal, and exponents
				if(number instanceof Integer || number instanceof Long || number instanceof BigInteger)	//if this is an integer
				{
					resourceURI=createLexicalURI(INTEGER_CLASS_URI, number.toString());	//create an integer URI for the resource
				}
				else if(number instanceof Float || number instanceof Double || number instanceof BigDecimal)	//if this is an real
				{
					resourceURI=createLexicalURI(REAL_CLASS_URI, number.toString());	//create a real URI for the resource
				}
				else	//if we don't recognize the number type
				{
					throw new AssertionError("Unrecognized number type produced: "+number.getClass());
				}
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case ORDINAL_BEGIN:	//number
				foundComponent=true;	//indicate that at least one description component is present
				final Number ordinal=parseNumber(reader, ORDINAL_BEGIN, false, false, false);	//parse the number, only allowing positive integers (which should produce an integer object)
				resourceURI=createOrdinalURI(ordinal.longValue());	//create an ordinal URI for the resource
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case REGULAR_EXPRESSION_BEGIN:	//regular expression
				foundComponent=true;	//indicate that at least one description component is present
				final String regularExpressionString=parseString(reader, REGULAR_EXPRESSION_BEGIN, REGULAR_EXPRESSION_END);	//parse the regular expression string
				resourceURI=createLexicalURI(REGULAR_EXPRESSION_CLASS_URI, regularExpressionString);	//create a URI for the regular expression
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case STRING_BEGIN:	//string
				foundComponent=true;	//indicate that at least one description component is present
				final String string=parseString(reader, STRING_BEGIN, STRING_END);	//parse the string
				resourceURI=createLexicalURI(STRING_CLASS_URI, string);	//create a URI for the string
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			case URI_BEGIN:	//URI
				foundComponent=true;	//indicate that at least one description component is present
				final URI uri=parseURI(reader, baseURI, URI_BEGIN, URI_END);	//parse the URI
				resourceURI=createLexicalURI(URI_CLASS_URI, uri.toString());	//create a URI for the resource
				c=skipSeparators(reader);	//skip separators and peek the next character
				break;
			default:	//if there was some other character, see if it's a name
				if(isNameCharacter(c))	//if this is a name character
				{
					final NameValuePair<String, String> name=parseName(reader);	//parse the name
					final URI namespaceURI;	//we'll determine the namespace URI
					final String prefix=name.getName();	//get the name prefix
					final String localName=name.getValue();	//get the name local name
					if(prefix!=null)	//if there is a prefix, see to which namespace URI it refers
					{
						namespaceURI=toURI(reader, getResourceProxy(prefix));	//get a resource proxy for the prefix and use it as a URI
					}
					else	//if there is no prefix, get the default namespace for this context
					{
						if(contextURI==null)	//if no context is available
						{
							throw new ParseIOException(reader, "Local name "+localName+" has no context for namespace determination.");
						}
						namespaceURI=getNamespaceURI(contextURI);	//get the namespace URI from the context URI
						if(namespaceURI==null)	//if no namespace is available
						{
							throw new ParseIOException(reader, "Context URI "+contextURI+" has no namespace.");
						}
					}
					foundComponent=true;	//indicate that at least one description component is present
					try
					{
						resourceURI=createResourceURI(namespaceURI, localName);	//create the resource URI from the namespace URI and local name
//Debug.trace("from namespace", namespaceURI, "and local name", localName, "formed URI", resourceURI);
					}
					catch(final IllegalArgumentException illegalArgumentException)	//if the given namespace is not valid
					{
						throw new ParseIOException(reader, "Prefix "+prefix+" references invalid namespace "+namespaceURI);
					}
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
				break;
		}
		if(resourceURI!=null && isLexicalURI(resourceURI))	//if there is a resource URI that is in a lexical namespace
		{
			types.add(getResourceProxy(getLexicalTypeURI(resourceURI)));	//add a proxy to the lexical type
		}		
		if(c==TYPE_BEGIN)	//check for a type TODO see if there is any way we can specify the context subject/predicate when parsing the type, in case the type in here has scoped properties (highly unlikely---maybe forbid this in the spec)
		{
			foundComponent=true;	//indicate that at least one description component is present
			check(reader, TYPE_BEGIN);	//read the beginning type delimiter
			final Resource[] typeResources=parseResourceList(reader, baseURI, TYPE_END);	//parse the resources serving as types
			addAll(types, typeResources);	//add all the types we found
			check(reader, TYPE_END);	//read the ending type delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
			//make sure we know about the type if possible by checking for the list short form of the set short form
		if(c==LIST_BEGIN)	//check for the list short form
		{
			foundComponent=true;	//indicate that at least one description component is present
			if(types.isEmpty())	//if no types have been specified
			{
				types.add(getResourceProxy(LIST_CLASS_URI));	//add a proxy to the list type, but don't read the list, yet; we'll do that after creating the resource proxy
			}
		}
		else if(c==SET_BEGIN)	//check for the set short form
		{
			foundComponent=true;	//indicate that at least one description component is present
			if(types.isEmpty())	//if no types have been specified
			{
				types.add(getResourceProxy(SET_CLASS_URI));	//add a proxy to the set type, but don't read the set, yet; we'll do that after creating the resource proxy
			}
		}
		if(!foundComponent && c!=PROPERTIES_BEGIN)	//if there were no description components so far, and we don't see any properties coming up
		{
			checkReaderNotEnd(reader, c);	//make sure we're not at the end of the reader
			throw new ParseIOException(reader, "Expected resource; found character: "+(char)c);
		}
//Debug.trace("ready to get resource proxy for label", label, "resource URI", resourceURI);
		final ResourceProxy resourceProxy=getResourceProxy(label, resourceURI);	//get a resource proxy from the label and/or reference URI, or use one already available for the reference URI
//Debug.trace("type count", types.size());
		if(!types.isEmpty())	//if we have at least one type
		{
			final Resource typePropertyResource=getResourceProxy(TYPE_PROPERTY_URI);	//get a proxy to the type property resource
			for(final Resource type:types)	//for each type
			{
				addAssertion(new Assertion(resourceProxy, typePropertyResource, type));	//assert this type
			}
		}
		if(c==LIST_BEGIN)	//if a list is next
		{
			long index=0;	//start out with an index of zero
			check(reader, LIST_BEGIN);	//read the beginning list delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
			while(c>=0 && c!=SEQUENCE_END)	//while the end of the sequence has not been reached and there is another resource to parse
			{
				final Resource indexPredicate=getResourceProxy(createOrdinalURI(index));	//get the ordinal property for specifying the index of each value
				final Resource element=parseResource(reader, baseURI, resourceProxy, new ArrayList<NameValuePair<Resource,Resource>>(), indexPredicate, indexPredicate.getURI());	//parse the list element, giving a scope chain predicate in case a scope is formed for the value
				addAssertion(new Assertion(resourceProxy, indexPredicate, element));	//assert the assertion that the element is an index of the list; there is no scope with an list short form
				++index;	//go to the next index
				c=skipSeparators(reader);	//skip separators and peek the next character
				if(c==LIST_DELIMITER)	//if this is a list delimiter
				{
					check(reader, LIST_DELIMITER);	//skip the list delimiter
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
				else	//if there's anything besides a list delimiter, we've reached the end of the list
				{
					break;	//stop parsing the list
				}
			}
			check(reader, LIST_END);	//read the ending list delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}		
		if(c==SET_BEGIN)	//if a set is next
		{
			check(reader, SET_BEGIN);	//read the beginning set delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
			final Resource elementPredicate=getResourceProxy(ELEMENT_PROPERTY_URI);	//get the element property resource proxy
			while(c>=0 && c!=SEQUENCE_END)	//while the end of the sequence has not been reached and there is another resource to parse
			{
				final Resource element=parseResource(reader, baseURI, resourceProxy, new ArrayList<NameValuePair<Resource,Resource>>(), elementPredicate, elementPredicate.getURI());	//parse the set element, giving a scope chain predicate in case a scope is formed for the value
				addAssertion(new Assertion(resourceProxy, elementPredicate, element));	//assert the assertion that the element is an element of the set; there is no scope with a set short form
				c=skipSeparators(reader);	//skip separators and peek the next character
				if(c==LIST_DELIMITER)	//if this is a list delimiter
				{
					check(reader, LIST_DELIMITER);	//skip the list delimiter
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
				else	//if there's anything besides a list delimiter, we've reached the end of the list
				{
					break;	//stop parsing the list
				}
			}
			check(reader, SET_END);	//read the ending set delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}		
		if(c==PROPERTIES_BEGIN)	//check for properties
		{
			check(reader, PROPERTIES_BEGIN);	//read the beginning properties delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
			while(c!=PROPERTIES_END)	//while we haven't reached the end of the properties
			{			
				final Resource predicate=parseResource(reader, baseURI, null, null, null, !types.isEmpty() ? types.get(0).getURI() : null);	//parse the predicate resource, indicating the type (if any) as the context URI
				skipSeparators(reader);	//skip separators
				final char propertyValueDelimiter=check(reader, PROPERTY_VALUE_DELIMITERS);	//read the next character and make sure it's a property-value delimiter
				final Resource object;	//we'll use this to store the object, if there is just one object
				switch(skipSeparators(reader))	//skip separators and see what the next character will be
				{
					case SEQUENCE_BEGIN:	//sequence short form
						final Resource orderPredicate=getResourceProxy(ORDER_PROPERTY_URI);	//get the order property for specifying scoped order for each value
						long order=0;	//start out with an order of zero
						check(reader, SEQUENCE_BEGIN);	//read the beginning sequence delimiter
						c=skipSeparators(reader);	//skip separators and peek the next character
						while(c>=0 && c!=SEQUENCE_END)	//while the end of the sequence has not been reached and there is another resource to parse
						{
							final Resource sequenceObject=parseResource(reader, baseURI, resourceProxy, new ArrayList<NameValuePair<Resource,Resource>>(), predicate, predicate.getURI());	//parse the object, giving a scope chain predicate in case a scope is formed for the value
							addAssertion(new Assertion(resourceProxy, predicate, sequenceObject));	//assert the assertion with no scope
							final Resource orderObject=getResourceProxy(createIntegerURI(order));	//get a proxy to the order value
							final Resource newScopeBase=scopeBase!=null ? scopeBase : resourceProxy;	//if we don't have a scope base, use the subject resource as the base
							final ArrayList<NameValuePair<Resource, Resource>> newScopeChain=scopeChain!=null ? (ArrayList<NameValuePair<Resource, Resource>>)scopeChain.clone() : new ArrayList<NameValuePair<Resource,Resource>>();	//clone the scope chain or create a new one if needed
							newScopeChain.add(new NameValuePair<Resource, Resource>(predicate, sequenceObject));	//add another element to the scope chain for this new sequence object we parsed
							addAssertion(new Assertion(newScopeBase, orderPredicate, orderObject, newScopeChain.toArray(new NameValuePair[newScopeChain.size()])));	//assert the scoped order assertion
							++order;	//increaes the order for next time
							c=skipSeparators(reader);	//skip separators and peek the next character
							if(c==LIST_DELIMITER)	//if this is a list delimiter
							{
								check(reader, LIST_DELIMITER);	//skip the list delimiter
								c=skipSeparators(reader);	//skip separators and peek the next character
							}
							else	//if there's anything besides a list delimiter, we've reached the end of the list
							{
								break;	//stop parsing the list
							}
						}
						check(reader, SEQUENCE_END);	//read the ending sequence delimiter
						break;
					default:	//assume everything else is a normal resource object
						switch(propertyValueDelimiter)	//see what sort of assignment this is
						{
							case SCOPED_PROPERTY_VALUE_DELIMITER:	//scoped property assignment
//Debug.trace("found scoped property", predicate);
								if(scopeBase!=null && scopeChain!=null && scopePredicate!=null)	//if we are in the scope of some subject and predicate
								{
									final ArrayList<NameValuePair<Resource, Resource>> newScopeChain=(ArrayList<NameValuePair<Resource, Resource>>)scopeChain.clone();	//clone the scope chain
									newScopeChain.add(new NameValuePair<Resource, Resource>(scopePredicate, resourceProxy));	//add another element to the scope chain
//Debug.trace("current scope base:", scopeBase);
									object=parseResource(reader, baseURI, scopeBase, newScopeChain, predicate, predicate.getURI());	//parse the object with the new scope and new predicate
									addAssertion(new Assertion(scopeBase, predicate, object, newScopeChain.toArray(new NameValuePair[newScopeChain.size()])));	//assert the assertion with the new scope
//Debug.trace("finished adding scoped base", newScopeBase, "scoped property", predicate, "with value", object);
									break;
								}									
							case PROPERTY_VALUE_DELIMITER:	//property assignment
								object=parseResource(reader, baseURI, resourceProxy, new ArrayList<NameValuePair<Resource,Resource>>(), predicate, predicate.getURI());	//parse the object, giving a scope chain predicate in case a scope is formed for the value
								addAssertion(new Assertion(resourceProxy, predicate, object));	//assert the assertion with no scope
								break;
							default:
								throw new AssertionError("Unrecognized property-value delimiter: "+propertyValueDelimiter);	//we already checked this character, so we shouldn't get an unknown delimiter here
						}
				}
				c=skipSeparators(reader);	//skip separators and peek the next character
	//Debug.trace("after property-value pair, peeked", (char)c);
				if(c==LIST_DELIMITER)	//if this is a list delimiter
				{
					check(reader, LIST_DELIMITER);	//skip the list delimiter
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
			}			
			check(reader, PROPERTIES_END);	//read the ending properties delimiter
		}
//Debug.trace("ready to return resource proxy with URI", resourceProxy.getURI());
		return resourceProxy;	//return the resource proxy we created
	}

	/**Parses a list of resources.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the list of resources or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param end The character that marks the end of the list.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public Resource[] parseResourceList(final Reader reader, final URI baseURI, final char end) throws IOException, ParseIOException	//TODO del end if not needed
	{
		final List<Resource> resourceList=new ArrayList<Resource>();	//create a new list in which to place the resources
		int c=skipSeparators(reader);	//skip separators and peek the next character
//Debug.trace("peeked", (char)c);
//TODO del if not needed		if(indexOf(RESOURCE_BEGINS, c)<0 && c!=LIST_DELIMITER)	//if this is not the beginning of a resource, return (but don't return for the list delimiter, which is an error
//TODO del		while(c>=0 &&)	//while we are not out of data
//TODO del if not needed		while(indexOf(RESOURCE_BEGINS, c)>=0)	//while there is another resource to parse
//TODO del		while(indexOf(RESOURCE_BEGINS, c)>=0)	//while there is another resource to parse
		while(c>=0 && c!=end)	//while the end of the data has not been reached and there is another resource to parse
		{
			final Resource resource=parseResource(reader, baseURI);	//parse another resource
//Debug.trace("parsed resource from list", resource);
			resourceList.add(resource);	//parse another resource and add it to the list
			c=skipSeparators(reader);	//skip separators and peek the next character
//Debug.trace("after resource, peeked", (char)c);
			if(c==LIST_DELIMITER)	//if this is a list delimiter
			{
				check(reader, LIST_DELIMITER);	//skip the list delimiter
				c=skipSeparators(reader);	//skip separators and peek the next character
			}
			else	//if there's anything besides a list delimiter, we've reached the end of the list
			{
				break;	//stop parsing the list
			}
		}
//Debug.trace("ready to return list of resources for end", end, "next character", (char)peek(reader));
		return resourceList.toArray(new Resource[resourceList.size()]);	//return the parsed resources
	}

	/**Parses a label surrounded by label delimiters.
	The current position must be that of the first label delimiter character.
	The new position will be that immediately after the last label delimiter character.
	@param reader The reader the contents of which to be parsed.
	@return The label parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if one of the label characters is not a name character, or the reader has no more characters before the current label is completely parsed.
	*/
	public static String parseLabel(final Reader reader) throws IOException, ParseIOException
	{
		check(reader, LABEL_BEGIN);	//read the beginning label delimiter
		final String label=parseNameSegment(reader);	//read the label
		check(reader, LABEL_END);	//read the ending label delimiter
		return label;	//return the label we read
	}

	/**Parses a name composed of name characters preceded by an optional prefix.
	The current position must be that of the first name character.
	The new position will be that immediately after the last name character.
	@param reader The reader the contents of which to be parsed.
	@return The name parsed from the reader, with the name of the name-value pair indicating the prefix or <code>null</code>, and the value representing the local name.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if thare are no name characters.
	*/
	public static NameValuePair<String, String> parseName(final Reader reader) throws IOException, ParseIOException
	{
		final String nameSegment=parseNameSegment(reader);	//parse a name segment
		final String prefix, localName;	//we'll determine a prefix and a local name
		if(confirm(reader, NAME_PREFIX_DELIMITER))	//if there is a name prefix delimiter
		{
			prefix=nameSegment;	//the first name segment is the prefix
			localName=parseNameSegment(reader);	//the following name segment is the local name
		}
		else	//if there is no name prefix delimiter
		{
			prefix=null;	//there is no prefix
			localName=nameSegment;	//the name segment is the local name
		}
		return new NameValuePair<String, String>(prefix, localName);	//return the prefix, if any, and the local name
	}

	/**Parses a segment of a name composed only of name characters.
	The current position must be that of the first name character.
	The new position will be that immediately after the last name character.
	@param reader The reader the contents of which to be parsed.
	@return The name parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if thare are no name characters.
	*/
	public static String parseNameSegment(final Reader reader) throws IOException, ParseIOException
	{
		final StringBuilder stringBuilder=new StringBuilder();	//create a string builder for reading the name segment
		int c;	//the character read
		while(true)
		{
			reader.mark(1);	//mark our current position
			c=reader.read();	//read another character
			if(isNameCharacter(c))	//if this is a name character
			{
				stringBuilder.append((char)c);	//append the character
			}
			else	//if this is not a name character
			{
				break;	//stop gathering name characters
			}
		}
		if(stringBuilder.length()==0)	//if we didn't read any characters
		{
			checkReaderNotEnd(reader, c);	//make sure we're not at the end of the reader
			throw new ParseIOException(reader, "Expected name character; found "+(char)c+".");
		}
		if(c>=0)	//if we didn't reach the end of the stream
		{
			reader.reset();	//reset to the last mark, which was set right before the non-name character we found
		}
		return stringBuilder.toString();	//return the name segment we read
	}

	/**Parses binary data surrounded by binary delimiters.
	The current position must be that of the first binary delimiter character.
	The new position will be that immediately after the last binary delimiter character.
	@param reader The reader the contents of which to be parsed.
	@return The binary data parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current URI is completely parsed.
	@exception ParseIOException if the binary data is not correctly encoded base64url data with no linebreaks or if the reader has no more characters before the current binary data is completely parsed.
	*/
	public byte[] parseBinary(final Reader reader) throws IOException, ParseIOException
	{
		check(reader, BINARY_BEGIN);	//read the beginning binary delimiter
		final String base64urlString=reachAfter(reader, BINARY_END);	//read the rest of the binary data
		try
		{
			return Base64.decode(base64urlString.getBytes(UTF_8), 0, base64urlString.length(), Base64.URL_SAFE&Base64.DONT_BREAK_LINES);	//decode and return the data
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if the string was not valid base64url-encoded data
		{
			throw new ParseIOException(reader, illegalArgumentException);
		}
	}

	/**Parses a boolean surrounded by boolean delimiters.
	The current position must be that of the beginning boolean delimiter character.
	The new position will be that immediately after the last boolean character.
	@param reader The reader the contents of which to be parsed.
	@return The boolean parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the boolean is not syntactically correct or if the reader has no more characters before the current boolean is completely parsed.
	*/
	public static boolean parseBoolean(final Reader reader) throws IOException, ParseIOException
	{
		check(reader, BOOLEAN_BEGIN);	//read the beginning boolean delimiter
		final boolean b;	//we'll store the boolean here
		int c=peek(reader);	//peek the next character
		switch(c)	//see what the next character is
		{
			case BOOLEAN_FALSE_BEGIN:	//false
				check(reader, BOOLEAN_FALSE_LEXICAL_FORM);	//make sure this is really false
				b=false;	//store the boolean value
				break;
			case BOOLEAN_TRUE_BEGIN:	//true
				check(reader, BOOLEAN_TRUE_LEXICAL_FORM);	//make sure this is really true
				b=true;	//store the boolean value
				break;
			default:	//if we don't recognize the start of the boolean lexical form
				checkReaderNotEnd(reader, c);	//make sure we're not at the end of the reader
				throw new ParseIOException(reader, "Unrecognized start of boolean: "+(char)c);
		}
		return b;	//return the boolean we read
	}

	/**Parses a number beginning with a number delimiter.
	The current position must be that of the beginning number delimiter character.
	The new position will be that immediately after the last number character.
	This implementation returns a {@link Long} for all values with no decimal or exponent, and a {@link Double} for all other values.
	@param reader The reader the contents of which to be parsed.
	@param numberBegin The beginning number delimiter.
	@param allowMinus Whether the number allows an optional introductory minus sign.
	@param allowDecimal Whether the number allows an optional decimal part.
	@param allowExponent Whether the number allows an optional exponent part.
	@return The number parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current number is completely parsed.
	*/
	public static Number parseNumber(final Reader reader, final char numberBegin, final boolean allowMinus, final boolean allowDecimal, final boolean allowExponent) throws IOException, ParseIOException
	{
		boolean hasFraction=false;	//we don't have a fraction yet
		boolean hasExponent=false;	//we don't have an exponent yet
		check(reader, numberBegin);	//read the beginning number delimiter
		int c;	//we'll use this to keep track of the next character
		final StringBuilder stringBuilder=new StringBuilder();	//create a new string builder to use when reading the number
		if(allowMinus)	//if we should allow the minus sign
		{
			c=peek(reader);	//peek the first character
			if(c=='-')	//if the number starts with a minus sign
			{
				stringBuilder.append(check(reader, '-'));	//append the character
			}
		}
		stringBuilder.append(check(reader, '0', '9'));	//there should be at least one digit
		stringBuilder.append(read(reader, '0', '9')); //read all remaining digits
		c=peek(reader);	//peek the next character
		if(c>=0)	//if we're not at the end of the reader
		{
			if(allowDecimal && c=='.')	//if we should allow a decimal part and this is a floating point number
			{
				hasFraction=true;	//we found a fraction
				stringBuilder.append(check(reader, '.'));	//read and append the beginning decimal point
				stringBuilder.append(check(reader, '0', '9'));	//there should be at least one digit
				stringBuilder.append(read(reader, '0', '9')); //read all remaining digits
				c=peek(reader);	//peek the next character
			}
			if(allowExponent && c=='e')	//if we should allow an exponent part and this is an exponent
			{
				hasExponent=true;	//we found an exponent
				stringBuilder.append(check(reader, 'e'));	//read and append the exponent character
				c=peek(reader);	//peek the next character
				if(c=='-' || c=='+')	//if the exponent starts with a sign
				{
					stringBuilder.append(readCharacter(reader));	//append the sign					
				}
				stringBuilder.append(check(reader, '0', '9'));	//there should be at least one digit
				stringBuilder.append(read(reader, '0', '9')); //read all remaining digits
			}
		}
		try
		{
			if(hasFraction || hasExponent)	//if there was a fraction or exponent
			{
				return Double.valueOf(Double.parseDouble(stringBuilder.toString()));	//parse a double and return it
			}
			else	//if there is no fraction or exponent
			{
				return Long.valueOf(Long.parseLong(stringBuilder.toString()));	//parse a long and return it
			}
		}
		catch(final NumberFormatException numberFormatException)	//if the number was not syntactically correct
		{
			throw new ParseIOException(reader, numberFormatException);
		}
	}

	/**Parses a string surrounded by string delimiters.
	The current position must be that of the first string delimiter character.
	The new position will be that immediately after the string number delimiter character.
	@param reader The reader the contents of which to be parsed.
	@param stringBegin The beginning string delimiter.
	@param stringEnd The ending string delimiter.
	@return The string parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the string is not escaped correctly or reader has no more characters before the current string is completely parsed.
	*/
	public static String parseString(final Reader reader, final char stringBegin, final char stringEnd) throws IOException, ParseIOException
	{
		check(reader, stringBegin);	//read the beginning string delimiter
		final StringBuilder stringBuilder=new StringBuilder();	//create a new string builder to use when reading the string
		char c=readCharacter(reader);	//read a character
		while(c!=stringEnd)	//keep reading character until we reach the end of the string
		{
			if(c==STRING_ESCAPE)	//if this is an escape character
			{
				c=readCharacter(reader);	//read another a character
				switch(c)	//see what the next character
				{
					case STRING_ESCAPE:	//escape character
						break;	//use the escaped escape character unmodified
					case ESCAPED_BACKSPACE:	//b backspace
						c=BACKSPACE_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_FORM_FEED:	//f form feed
						c=FORM_FEED_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_LINE_FEED:	//n line feed
						c=LINE_FEED_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_CARRIAGE_RETURN:	//r carriage return
						c=CARRIAGE_RETURN_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_TAB:	//t tab
						c=HORIZONTAL_TABULATION_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_START_OF_STRING:	//“ start of string
						c=START_OF_STRING_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_STRING_TERMINATOR:	//” string terminator
						c=STRING_TERMINATOR_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_UNICODE:	//u Unicode
						final String unicodeString=readString(reader, 4);	//read the four Unicode code point hex characters
							//TODO make sure the Unicode sequence is lowercase
						c=(char)Integer.parseInt(unicodeString, 16);	//parse the hex characters and use the resulting code point
						break;
					default:	//if another character was escaped
						if(c!=stringBegin && c!=stringEnd)	//if this is not the delimiter that was escaped
						{
							throw new ParseIOException(reader, "Unknown escaped character: "+c);
						}
						break;
				}
			}
			stringBuilder.append(c);	//append the character to the string we are constructing
			c=readCharacter(reader);	//read another a character
		}
		return stringBuilder.toString();	//return the string we constructed
	}

	/**Parses a URI surrounded by specified URI delimiters.
	The current position must be that of the first URI delimiter character.
	The new position will be that immediately after the last URI delimiter character.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param uriBegin The beginning URI delimiter.
	@param uriEnd The ending URI delimiter.
	@return The URI parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current URI is completely parsed.
	*/
	public URI parseURI(final Reader reader, final URI baseURI, final char uriBegin, final char uriEnd) throws IOException, ParseIOException
	{
		check(reader, uriBegin);	//read the beginning URI delimiter
		int c=peek(reader);	//peek the next character
		final String lexicalForm;	//the lexical form, if any
		if(c==STRING_BEGIN)	//check for a string
		{
			lexicalForm=parseString(reader, STRING_BEGIN,	STRING_END);	//parse the string
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		else	//if no string was encountered
		{
			lexicalForm=null;	//show that there is no string
		}
		final String label;	//the label reference, if any
		if(c==LABEL_BEGIN)	//check for a label
		{
			label=parseLabel(reader);	//parse the label
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		else	//if no label was encountered
		{
			label=null;	//show that there is no label
		}
		try
		{
			URI uri=new URI(reachAfter(reader, uriEnd));	//read the rest of the URI
			if(label!=null)	//if we have a label, dereference that as a base URI and resolve this URI against it
			{
				final URI localBaseURI=toURI(reader, getResourceProxy(label));	//get a resource proxy for the label and use it as a URI
				uri=resolve(localBaseURI, uri);	//resolve the URI against the local base URI				
			}
			if(lexicalForm!=null)	//if we have a lexical form, use the existing URI as a type and create a lexical URI
			{
				uri=createLexicalURI(uri, lexicalForm);	//create a lexical URI using the lexical form and the type URI
			}
			if(baseURI!=null)	//if there is a base URI
			{
				uri=resolve(baseURI, uri);	//resolve the URI against the base URI				
			}
			return uri;	//return the resulting URI
		}
		catch(final URISyntaxException uriSyntaxException)	//if one of the strings was not a valid URI
		{
			throw new ParseIOException(reader, uriSyntaxException);
		}
	}

	/**Determines the URI represented by the given resource.
	@param reader The reader the contents of which to be parsed.
	@param resource The resource which is expected to represent a URI.
	@exception ParseIOException if the given resource has no URI or the URI does not represent a URI.
	*/
	protected static URI toURI(final Reader reader, final Resource resource) throws ParseIOException
	{
		try
		{
			final URI uri=asURI(resource);	//get the resource as a URI
			if(uri==null)	//if this isn't a URI
			{
				throw new ParseIOException(reader, "Resource "+resource+" is not a URI.");
			}
			return uri;	//return the URI
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if the URI wasn't in correct form
		{
			throw new ParseIOException(reader, "Resource "+resource+" is not a valid URI.", illegalArgumentException);
		}
	}

}