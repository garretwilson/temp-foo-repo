package com.garretwilson.urf;

import java.io.*;
import java.math.*;
import java.net.*;
import java.util.*;
import static java.util.Collections.*;

import com.garretwilson.io.ParseIOException;
import static com.garretwilson.io.ReaderParser.*;
import static com.garretwilson.iso.ISO8601.*;
import com.garretwilson.net.*;
import static com.garretwilson.net.URIs.*;
import static com.garretwilson.text.CharacterEncodingConstants.*;
import static com.garretwilson.text.CharacterConstants.*;
import static com.garretwilson.urf.URF.*;
import static com.garretwilson.urf.TURF.*;
import com.garretwilson.util.*;

/**Constructs an URF data instance from a TURF representation.
The TURF processor maintains an internal URF data model throughout its lifetime that is continually updated with every new URF processing that occurs.
The TURF processor maintains TURF data in two separate formats: the URF data model, {@link URF}, as well as a list of assertions used to create the data model.
The URF data model may be replaced and its members modified, but these actions will not update the list of URF assertions.
The URF statements are only generated by the TURF processor itself as it parses TURF, and are available to give information on the parser actions.
<p>Copyright © 2007 GlobalMentor, Inc.
This source code can be freely used for any purpose, as long as the following conditions are met.
Any object code derived from this source code must include the following text to users using along with other "about" notifications:
"Uniform Resource Framework (URF) &lt;http://www.urf.name/&gt; specification and processing
written by Garret Wilson &lt;http://www.garretwilson.com/&gt; and Copyright © 2007 GlobalMentor, Inc. &lt;http://www.globalmentor.com/&gt;."
Any redistribution of this source code or derived source code must include these comments unmodified.</p>
@author Garret Wilson
*/
public class URFTURFProcessor extends AbstractURFProcessor
{

	/**Default constructor.*/
	public URFTURFProcessor()
	{
		this(new URF());  //create an URF data model to use
	}

	/**Constructor that specifies an existing data model to continue filling.
	@param urf The URF data model to use.
	*/
	public URFTURFProcessor(final URF urf)
	{
		super(urf);  //construct the parent class
	}

	/**Parses all resources and then processes the resulting URF instance.
	The current position must be that of the TURF signature, {@value TURF#TURF_SIGNATURE}}.
	The new position will be the end of the reader,
	and any data appearing after the resources will be considered a syntax error.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return A list of the top-level resources parsed.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public List<URFResource> process(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		Map<String, URI> prefixNamespaceURIMap=emptyMap();	//start out with no namespaces defined
		check(reader, TURF_SIGNATURE);	//read the TURF signature
		int c=skipSeparators(reader);	//skip separators
		if(c==PROPERTIES_BEGIN)	//check for a TURF preamble
		{
			check(reader, PROPERTIES_BEGIN);	//read the beginning preamble delimiter			
			c=skipSeparators(reader);	//skip separators and peek the next character
			if(c!=PROPERTIES_END)	//if this is not an empty preamble
			{
				try
				{
					while(c>=0)	//while the end of the data has not been reached
					{
						final URI namespacePrefixResourceURI=parseReference(reader, baseURI);	//parse a reference to the namespace prefix
						final String namespacePrefix=asString(namespacePrefixResourceURI);	//get the namespace prefix
						if(namespacePrefix==null)	//if there is no namespace prefix
						{
							throw new DataException("Expected namespace prefix reference"+(namespacePrefixResourceURI!=null ? "; found: "+namespacePrefixResourceURI : "."));
						}
						skipSeparators(reader);	//skip separators
						check(reader, NAMESPACE_ASSOCIATION_DELIMITER);	//read the namespace association delimiter
						skipSeparators(reader);	//skip separators
						final URI namespaceURIResourceURI=parseReference(reader, baseURI);	//parse a reference to the namespace URI
						final URI namespaceURI=asURI(namespaceURIResourceURI);	//get the namespace URI
						if(namespaceURI==null)	//if there is no namespace URI
						{
							throw new DataException("Expected namespace URI; found reference: "+namespaceURIResourceURI);
						}
						if(prefixNamespaceURIMap.isEmpty())	//if we haven't added any namespaces, yet, we're using the empty map
						{
							prefixNamespaceURIMap=new HashMap<String, URI>();	//create a new map that is mutable
						}
						prefixNamespaceURIMap.put(namespacePrefix, namespaceURI);	//store the TURF namespace prefix association
						c=skipSeparators(reader);	//skip separators and peek the next character
						if(c==LIST_DELIMITER)	//if this is a list delimiter
						{
							check(reader, LIST_DELIMITER);	//skip the list delimiter
							c=skipSeparators(reader);	//skip separators and peek the next character
						}
						else	//if there's anything besides a list delimiter, we've reached the end of the properties
						{
							break;	//stop parsing the list
						}
					}
				}
				catch(final DataException dataException)
				{
					throw new ParseIOException(reader, dataException);
				}
			}
			check(reader, PROPERTIES_END);	//read the ending preamble delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		check(reader, COMMUNITY_BEGIN);	//read the beginning instance community delimiter
		skipSeparators(reader);	//skip separators
		final List<URFResource> urfResourceList=processResources(reader, baseURI, COMMUNITY_END, prefixNamespaceURIMap);	//process resources, indicating the end of the instance community
		check(reader, COMMUNITY_END);	//read the ending community delimiter
		return urfResourceList;	//return the URF resources parsed
	}

	/**Parses a list of resources resources and then processes the resulting URF instance.
	The current position must that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return A list of the top-level resources parsed.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public List<URFResource> processResources(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		return processResources(reader, baseURI, NULL_CHAR, (Map<String, URI>)EMPTY_MAP);	//parse the resources, with no particular end of list indicated
	}

	/**Parses a list of resources resources and then processes the resulting URF instance.
	The current position must that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param listEnd The character that marks the end of the list.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return A list of the top-level resources parsed.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	protected List<URFResource> processResources(final Reader reader, final URI baseURI, final char listEnd, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException
	{
		reset();	//make sure we don't have temporary data left over from last time
		final List<Resource> resources=parseResourceList(reader, baseURI, listEnd, prefixNamespaceURIMap);	//parse the list of resources
		final List<URFResource> urfResources;	//we'll create a separate list of the URF resources corresponding to the resource proxies
		try
		{
			createResources();	//create all resources
			processAssertions();	//process the collected assertions
			urfResources=new ArrayList<URFResource>(resources.size());	//create a new list to hold URF resources
			for(final Resource resource:resources)	//for each resource
			{
				urfResources.add(resource instanceof URFResource ? (URFResource)resource : unproxyURFResource((ResourceProxy)resource));	//add this resource, unproxying it if we need to
			}
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if something was wrong with one of the resources
		{
			throw new ParseIOException(reader, illegalArgumentException);
		}
		reset();	//release all our references temporary resource proxies
		return urfResources;	//return the list of URF resources
	}

	/**Skips over TURF separators in a reader.
	This method skips all separator characters {@link TURF#SEPARATORS}, as well as any comments.
	The new position will either be the that of the first non-separator character or the end of the input stream.
	@param reader The reader the contents of which to be parsed.
	@return The next character that will be returned the reader's {@link Reader#read()} operation, or <code>-1</code> if the end of the reader has been reached.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	*/
	protected static int skipSeparators(final Reader reader) throws IOException
	{
		int c;	//we'll store the next non-separator character here so that it can be returned
		while((c=skip(reader, SEPARATORS))==COMMENT_BEGIN)	//skip all separators; if the start of a comment was encountered
		{
			check(reader, COMMENT_BEGIN);	//read the beginning comment delimiter
			pass(reader, COMMENT_END);	//skip past the end of the comment; we'll then skip all separator characters and see if another comment starts
		}
		return c;	//return the last character read
	}

	/**Parses a single resource and returns a proxy to the resource.
	The current position must be that of the first character of the resource.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	*/
	public Resource parseResource(final Reader reader, final URI baseURI) throws IOException, ParseIOException
	{
		return parseResource(reader, baseURI, null, (Map<String, URI>)EMPTY_MAP);	//parse a resource with no context URI or namespace prefixes
	}

	/**Parses a single resource and returns a proxy to the resource.
	The current position must be that of the first character of the resource.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param defaultNamespaceURI The URI of the default namespace, or <code>null</code> if no default namespace is allowed; for properties, this is the URI of the first type short form.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	*/
	public Resource parseResource(final Reader reader, final URI baseURI, final URI defaultNamespaceURI, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException
	{
		try
		{
			return parseResource(reader, baseURI, null, null, null, defaultNamespaceURI, prefixNamespaceURIMap);	//parse a resource with no scope
		}
		catch(final DataException dataException)
		{
			throw new ParseIOException(reader, dataException);
		}
	}

	/**Parses a single optionally scoped resource with no default namespace URI and returns a proxy to the resource.
	The current position must be that of the first character of the resource.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	For every resource that is being parsed as the object of a subject and predicate, the scope base, scope chain, and scope predicate must all be non-<code>null</code>.
	Whenever the scope chain is lengthened it must first be cloned so that the local version will not be modified during recursion.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param scopeBase The base resource of the current scope, or <code>null</code> if the current resource is not in an object context.
	@param scopeChain The chain of scope, each element representing a property and value to serve as scope for the subsequent property and value, or <code>null</code> if there is no current scope.
	@param scopePredicate The predicate for which the new resource is a value, or <code>null</code> if the current resource is not in an object context.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	@exception DataException if there was an error with information being processed.
	*/
	protected Resource parseResource(final Reader reader, final URI baseURI, final Resource scopeBase, final ArrayList<NameValuePair<Resource, Resource>> scopeChain, final Resource scopePredicate, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException, DataException
	{
		return parseResource(reader, baseURI, scopeBase, scopeChain, scopePredicate, null, prefixNamespaceURIMap);	//parse the resource with no default namespace URI
	}

	/**Parses a single optionally scoped resource and returns a proxy to the resource.
	The current position must be that of the first character of the resource.
	The new position will be that of the first non-separator character after the resource or the end of the reader.
	For every resource that is being parsed as the object of a subject and predicate, the scope base, scope chain, and scope predicate must all be non-<code>null</code>.
	Whenever the scope chain is lengthened it must first be cloned so that the local version will not be modified during recursion.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param scopeBase The base resource of the current scope, or <code>null</code> if the current resource is not in an object context.
	@param scopeChain The chain of scope, each element representing a property and value to serve as scope for the subsequent property and value, or <code>null</code> if there is no current scope.
	@param scopePredicate The predicate for which the new resource is a value, or <code>null</code> if the current resource is not in an object context.
	@param defaultNamespaceURI The URI of the default namespace, or <code>null</code> if no default namespace is allowed; for properties, this is the URI of the first type short form.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The resource parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	@exception DataException if there was an error with information being processed.
	*/
	protected Resource parseResource(final Reader reader, final URI baseURI, final Resource scopeBase, final ArrayList<NameValuePair<Resource, Resource>> scopeChain, final Resource scopePredicate, final URI defaultNamespaceURI, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException, DataException
	{
		final URF urf=getURF();	//get the URF data model
		String label=null;	//the label of the resource, if any
		final List<Resource> types=new ArrayList<Resource>();	//we'll keep track of all the types we find
		boolean foundComponent=false;	//we'll keep track of whether at least one description component was present
		int c=peek(reader);	//peek the next character
		if(c==LABEL_BEGIN)	//check for a label
		{
			foundComponent=true;	//indicate that at least one description component is present
			label=parseLabel(reader);	//parse the label
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		final URI resourceURI=parseReference(reader, baseURI, defaultNamespaceURI, prefixNamespaceURIMap);	//parse a reference to the resource, if any
		if(resourceURI!=null)	//if we parsed a reference
		{
			foundComponent=true;	//indicate that at least one description component is present
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		final Resource resource=determineResourceProxy(label, resourceURI);	//get a resource proxy from the label and/or reference URI, or use one already available for the reference URI
		final Resource typePropertyResource=determineResourceProxy(TYPE_PROPERTY_URI);	//get a proxy to the type property resource
		if(resourceURI!=null && isLexicalURI(resourceURI))	//if there is a resource URI that is in a lexical namespace
		{
			final Resource lexicalType=determineResourceProxy(getLexicalTypeURI(resourceURI));	//get a proxy to the lexical type
			types.add(lexicalType);	//add the lexical type to our list of types
			addAssertion(new Assertion(resource, typePropertyResource, lexicalType));	//assert the lexical type
		}
		if(c==TYPES_BEGIN)	//check for types
		{
			foundComponent=true;	//indicate that at least one description component is present
			check(reader, TYPES_BEGIN);	//read the beginning type delimiter
			types.addAll(parseSequence(reader, baseURI, defaultNamespaceURI, scopeBase, scopeChain, resource, typePropertyResource, false, TYPES_END, prefixNamespaceURIMap));	//parse the sequence of types, if any, and add them to our list of types
			check(reader, TYPES_END);	//read the ending type delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		final URI typeURI=!types.isEmpty() ? types.get(0).getURI() : null;	//the first type, if any, will determine the default namespace for properties and list/set short forms
		if(c==INITS_BEGIN)	//check for inits
		{
			foundComponent=true;	//indicate that at least one description component is present
			check(reader, INITS_BEGIN);	//read the beginning init delimiter
			final Resource initPropertyResource=determineResourceProxy(INITS_PROPERTY_URI);	//get a proxy to the init property resource
			final Resource listResource=createResourceProxy();	//create a proxy for the list resource
			addAssertion(new Assertion(resource, initPropertyResource, listResource));	//assert the list for the inits property
			final Resource listType=determineResourceProxy(LIST_CLASS_URI);	//get a proxy to the list type
			addAssertion(new Assertion(listResource, typePropertyResource, listType));	//assert the list type for the list
			parseListContents(reader, baseURI, listResource, INITS_END, prefixNamespaceURIMap);	//parse the init elements
			check(reader, INITS_END);	//read the ending init delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		if(c==PROPERTIES_BEGIN)	//check for properties
		{
			foundComponent=true;	//indicate that at least one description component is present
			check(reader, PROPERTIES_BEGIN);	//read the beginning properties delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
			if(c!=PROPERTIES_END)	//if this is not an empty properties section
			{
				while(c>=0)	//while the end of the data has not been reached
				{
					final Resource predicate=parseResource(reader, baseURI, null, null, null, typeURI, prefixNamespaceURIMap);	//parse the predicate resource, providing the typeURI (if any) as a default namespace URI
					final URI predicateURI=predicate.getURI();	//get the predicate URI
					c=skipSeparators(reader);	//skip separators
					if(c==LABEL_BEGIN)	//if this is the beginning of a property reification
					{
						throw new DataException("Property reification not yet supported.");	//TODO implement property reification
					}
					final boolean scoped;	//we'll determine if this is a scoped property
					if(c==SCOPE_DELIMITER)	//if this is the beginning of a scoped property
					{
						scoped=true;	//this is a scoped property
						check(reader, SCOPE_DELIMITER);	//read the scope begin character
						c=skipSeparators(reader);	//skip separators
					}
					else	//if there is no scope indicator
					{
						scoped=false;	//this is not a scoped property
					}
					check(reader, PROPERTY_VALUE_DELIMITER);	//read the property value delimiter
					final Resource object;	//we'll use this to store the object, if there is just one object
					if(skipSeparators(reader)==SEQUENCE_BEGIN)	//skip separators and see what the next character will be; if this is the beginning of a sequence
					{
						check(reader, SEQUENCE_BEGIN);	//read the beginning sequence delimiter
						final List<Resource> sequenceResources=parseSequence(reader, baseURI, predicateURI, scopeBase, scopeChain, resource, predicate, scoped, SEQUENCE_END, prefixNamespaceURIMap);	//parse the sequence of resources
						if(!scoped && TYPE_PROPERTY_URI.equals(predicateURI))	//if this was a sequence of types
						{
							types.addAll(sequenceResources);	//add all the resources in the sequence as types
						}
						check(reader, SEQUENCE_END);	//read the ending sequence delimiter
					}
					else	//assume everything else is a normal resource object
					{
						if(scoped)	//if this is a scoped property
						{
							if(scopeBase!=null && scopeChain!=null && scopePredicate!=null)	//if we are in the scope of some subject and predicate
							{
								final ArrayList<NameValuePair<Resource, Resource>> newScopeChain=(ArrayList<NameValuePair<Resource, Resource>>)scopeChain.clone();	//clone the scope chain
								newScopeChain.add(new NameValuePair<Resource, Resource>(scopePredicate, resource));	//add another element to the scope chain
								object=parseResource(reader, baseURI, scopeBase, newScopeChain, predicate, prefixNamespaceURIMap);	//parse the object with the new scope and new predicate
								addAssertion(new Assertion(scopeBase, predicate, object, newScopeChain.toArray(new NameValuePair[newScopeChain.size()])));	//assert the assertion with the new scope
							}
							else	//if there is no scope
							{
								throw new DataException("No parent scope available for scoped property.");
							}
						}
						else	//if this is not a scoped property
						{
							object=parseResource(reader, baseURI, resource, new ArrayList<NameValuePair<Resource,Resource>>(), predicate, prefixNamespaceURIMap);	//parse the object, giving a scope chain and predicate in case a scope is formed for the value
							addAssertion(new Assertion(resource, predicate, object));	//assert the assertion with no scope
							if(TYPE_PROPERTY_URI.equals(predicateURI))	//if this was a type declaration
							{
								types.add(object);	//make a note of this type
							}
						}
					}
					c=skipSeparators(reader);	//skip separators and peek the next character
					if(c==LIST_DELIMITER)	//if this is a list delimiter
					{
						check(reader, LIST_DELIMITER);	//skip the list delimiter
						c=skipSeparators(reader);	//skip separators and peek the next character
					}
					else	//if there's anything besides a list delimiter, we've reached the end of the properties
					{
						break;	//stop parsing the list
					}
				}
			}
			check(reader, PROPERTIES_END);	//read the ending properties delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		if(c==COMMUNITY_BEGIN)	//if a community is next
		{
			throw new DataException("Community short form not yet supported.");	//TODO implement community short form
		}
		if(c==PROPOSITION_BEGIN)	//if a proposition is next
		{
			foundComponent=true;	//indicate that at least one description component is present
			if(types.isEmpty())	//if no types have been specified
			{
				final Resource propositionType=determineResourceProxy(PROPOSITION_CLASS_URI);	//get a proxy to the proposition type
				types.add(propositionType);	//add a proxy to the proposition type
				addAssertion(new Assertion(resource, typePropertyResource, propositionType));	//assert the proposition type
			}
			long index=0;	//start out with an index of zero
			check(reader, PROPOSITION_BEGIN);	//read the beginning proposition delimiter
			skipSeparators(reader);	//skip separators
			final Resource subjectPredicate=determineResourceProxy(SUBJECT_PROPERTY_URI);	//get the subject predicate
			final Resource subject=parseResource(reader, baseURI, resource, new ArrayList<NameValuePair<Resource,Resource>>(), subjectPredicate, prefixNamespaceURIMap);	//parse the subject, giving a scope chain and predicate in case a scope is formed for the value
			addAssertion(new Assertion(resource, subjectPredicate, subject));	//assert the proposition subject
			skipSeparators(reader);	//skip separators
			check(reader, LIST_DELIMITER);	//read the list delimiter
			skipSeparators(reader);	//skip separators
			final Resource predicatePredicate=determineResourceProxy(PREDICATE_PROPERTY_URI);	//get the predicate predicate
			final Resource predicate=parseResource(reader, baseURI, resource, new ArrayList<NameValuePair<Resource,Resource>>(), predicatePredicate, prefixNamespaceURIMap);	//parse the predicate, giving a scope chain and predicate in case a scope is formed for the value
			addAssertion(new Assertion(resource, predicatePredicate, predicate));	//assert the proposition predicate
			skipSeparators(reader);	//skip separators
			check(reader, LIST_DELIMITER);	//read the list delimiter
			skipSeparators(reader);	//skip separators
			final Resource objectPredicate=determineResourceProxy(OBJECT_PROPERTY_URI);	//get the object predicate
			final Resource object=parseResource(reader, baseURI, resource, new ArrayList<NameValuePair<Resource,Resource>>(), objectPredicate, prefixNamespaceURIMap);	//parse the object, giving a scope chain and predicate in case a scope is formed for the value
			addAssertion(new Assertion(resource, objectPredicate, object));	//assert the proposition object
			skipSeparators(reader);	//skip separators
			check(reader, PROPOSITION_END);	//read the ending proposition delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		if(c==LIST_BEGIN)	//if a list is next
		{
			foundComponent=true;	//indicate that at least one description component is present
			if(types.isEmpty())	//if no types have been specified
			{
				final Resource listType=determineResourceProxy(LIST_CLASS_URI);	//get a proxy to the list type
				types.add(listType);	//add a proxy to the list type
				addAssertion(new Assertion(resource, typePropertyResource, listType));	//assert the list type
			}
			check(reader, LIST_BEGIN);	//read the beginning list delimiter
			parseListContents(reader, baseURI, resource, LIST_END, prefixNamespaceURIMap);	//parse the list elements
			check(reader, LIST_END);	//read the ending list delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		if(c==SET_BEGIN)	//if a set is next
		{
			foundComponent=true;	//indicate that at least one description component is present
			if(types.isEmpty())	//if no types have been specified
			{
				final Resource setType=determineResourceProxy(SET_CLASS_URI);	//get a proxy to the set type
				types.add(setType);	//add a proxy to the set type
				addAssertion(new Assertion(resource, typePropertyResource, setType));	//assert the set type
			}
			check(reader, SET_BEGIN);	//read the beginning set delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
			if(c!=SET_END)	//if this is not an empty set
			{
				final Resource elementPredicate=determineResourceProxy(ELEMENT_PROPERTY_URI);	//get the element property resource proxy
				while(c>=0)	//while the end of the data has not been reached
				{
					final Resource element=parseResource(reader, baseURI, resource, new ArrayList<NameValuePair<Resource,Resource>>(), elementPredicate, prefixNamespaceURIMap);	//parse the set element, giving a scope chain and predicate in case a scope is formed for the value
					addAssertion(new Assertion(resource, elementPredicate, element));	//assert the assertion that the element is an element of the set; there is no scope with a set short form
					c=skipSeparators(reader);	//skip separators and peek the next character
					if(c==LIST_DELIMITER)	//if this is a list delimiter
					{
						check(reader, LIST_DELIMITER);	//skip the list delimiter
						c=skipSeparators(reader);	//skip separators and peek the next character
					}
					else	//if there's anything besides a list delimiter, we've reached the end of the set
					{
						break;	//stop parsing the list
					}
				}
			}
			check(reader, SET_END);	//read the ending set delimiter
			c=skipSeparators(reader);	//skip separators and peek the next character
		}
		if(!foundComponent)	//if there were no description components
		{
			checkReaderNotEnd(reader, c);	//make sure we're not at the end of the reader
			throw new ParseIOException(reader, "Expected resource; found character: "+(char)c);
		}
		return resource;	//return the resource proxy we created
	}

	/**Parses a list of resources and adds the resources to the given resource as indexed property values.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the resources or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param listResource The subject resource to which the list element resources will be added.
	@param listEnd The character that marks the end of the list.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The list resource the contents of which were parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	@exception DataException if there was an error with information being processed.
	*/
	protected Resource parseListContents(final Reader reader, final URI baseURI, final Resource listResource, final char listEnd, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException, DataException
	{
		long index=0;	//start out with an index of zero
		int c=skipSeparators(reader);	//skip separators and peek the next character
		if(c!=listEnd)	//if this is not an empty list
		{
			while(c>=0)	//while the end of the data has not been reached
			{
				final Resource indexPredicate=determineResourceProxy(createOrdinalURI(index));	//get the ordinal property for specifying the index of each value
				final Resource element=parseResource(reader, baseURI, listResource, new ArrayList<NameValuePair<Resource,Resource>>(), indexPredicate, prefixNamespaceURIMap);	//parse the list element, giving a scope chain and predicate in case a scope is formed for the value
				addAssertion(new Assertion(listResource, indexPredicate, element));	//assert the assertion that the element is an index of the list; there is no scope with an list short form
				++index;	//go to the next index
				c=skipSeparators(reader);	//skip separators and peek the next character
				if(c==LIST_DELIMITER)	//if this is a list delimiter
				{
					check(reader, LIST_DELIMITER);	//skip the list delimiter
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
				else	//if there's anything besides a list delimiter, we've reached the end of the list
				{
					break;	//stop parsing the list
				}
			}
		}
		return listResource;	//return the list resource
	}
	
	/**Parses a sequence of resources and assigns them to the subject resource with scoped orders.
	The current position must be that of a separator or that of the first character of the first resource in the sequence.
	The new position will be that of the first non-separator character after the sequence of resources or the end of the reader.
	For every resource that is being parsed as the object of a subject and predicate, the scope base, scope chain, and scope predicate must all be non-<code>null</code>.
	Whenever the scope chain is lengthened it must first be cloned so that the local version will not be modified during recursion.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param defaultNamespaceURI The URI of the default namespace, or <code>null</code> if no default namespace is allowed; for properties, this is the URI of the first type short form.
	@param scopeBase The base resource of the current scope, or <code>null</code> if the current resource is not in an object context.
	@param scopeChain The chain of scope, each element representing a property and value to serve as scope for the subsequent property and value, or <code>null</code> if there is no current scope.
	@param subject The subject resource to which the sequence values will be added.
	@param predicate The predicate to use in adding sequence value.
	@param scoped Whether each predicate is scoped.
	@param sequenceEnd The character that marks the end of the sequence.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The resources in the list parsed from the reader.
	@exception NullPointerException if the given reader, subject, and/or predicate is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current resource is completely parsed.
	@exception DataException if there was an error with information being processed.
	*/
	protected List<Resource> parseSequence(final Reader reader, final URI baseURI, final URI defaultNamespaceURI, final Resource scopeBase, final ArrayList<NameValuePair<Resource, Resource>> scopeChain, final Resource subject, final Resource predicate, final boolean scoped, final char sequenceEnd, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException, DataException
	{
		final Resource orderPredicate=determineResourceProxy(ORDER_PROPERTY_URI);	//get the order property for specifying scoped order for each value
		long order=0;	//start out with an order of zero
		int c=skipSeparators(reader);	//skip separators and peek the next character
		if(c!=sequenceEnd)	//if this is not an empty list
		{
			final List<Resource> resourceList=new ArrayList<Resource>();	//create a new list in which to place the resources
			while(c>=0)	//while the end of the sequence has not been reached
			{
				final Resource sequenceObject=parseResource(reader, baseURI, subject, new ArrayList<NameValuePair<Resource,Resource>>(), predicate, prefixNamespaceURIMap);	//parse the object, giving a scope chain and predicate in case a scope is formed for the value
				addAssertion(new Assertion(subject, predicate, sequenceObject));	//assert the assertion with no scope
				resourceList.add(sequenceObject);	//add the sequence object to the list of resources
				final Resource orderObject=determineResourceProxy(createIntegerURI(order));	//get a proxy to the order value
				final Resource newScopeBase;	//we'll determine a new scope base
				final ArrayList<NameValuePair<Resource, Resource>> newScopeChain;	//we'll determine a new scope chain
				if(scoped)	//if this is a scoped property assignment
				{
					newScopeBase=scopeBase!=null ? scopeBase : subject;	//if we don't have a scope base, use the subject resource as the base
					newScopeChain=scopeChain!=null ? (ArrayList<NameValuePair<Resource, Resource>>)scopeChain.clone() : new ArrayList<NameValuePair<Resource,Resource>>();	//clone the scope chain or create a new one if needed
				}
				else	//if this is a normal property assignment
				{
					newScopeBase=subject;	//the resource will be the start of a new scope
					newScopeChain=new ArrayList<NameValuePair<Resource,Resource>>();	//start a new scope chains
				}
				newScopeChain.add(new NameValuePair<Resource, Resource>(predicate, sequenceObject));	//add another element to the scope chain for this new sequence object we parsed
				addAssertion(new Assertion(newScopeBase, orderPredicate, orderObject, newScopeChain.toArray(new NameValuePair[newScopeChain.size()])));	//assert the scoped order assertion
				++order;	//increaes the order for next time
				c=skipSeparators(reader);	//skip separators and peek the next character
				if(c==LIST_DELIMITER)	//if this is a list delimiter
				{
					check(reader, LIST_DELIMITER);	//skip the list delimiter
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
				else	//if there's anything besides a list delimiter, we've reached the end of the sequence
				{
					break;	//stop parsing the list
				}
			}
			return resourceList;	//return the parsed resources
		}
		return emptyList();	//the sequence is empty; return an empty list
	}

	/**Parses a list of resources.
	The current position must be that of a separator or that of the first character of the first resource in the list.
	The new position will be that of the first non-separator character after the list of resources or the end of the reader.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param listEnd The character that marks the end of the list.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The resources in the list parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if a resource in the list is missing, or if the reader has no more characters before a resource in the list is completely parsed.
	*/
	public List<Resource> parseResourceList(final Reader reader, final URI baseURI, final char listEnd, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException
	{
		int c=skipSeparators(reader);	//skip separators and peek the next character
		if(c!=listEnd)	//if this is not an empty list
		{
			final List<Resource> resourceList=new ArrayList<Resource>();	//create a new list in which to place the resources
			while(c>=0)	//while the end of the data has not been reached
			{
				final Resource resource=parseResource(reader, baseURI, null, prefixNamespaceURIMap);	//parse another resource
				resourceList.add(resource);	//add the resource to the list of resources
				c=skipSeparators(reader);	//skip separators and peek the next character
				if(c==LIST_DELIMITER)	//if this is a list delimiter
				{
					check(reader, LIST_DELIMITER);	//skip the list delimiter
					c=skipSeparators(reader);	//skip separators and peek the next character
				}
				else	//if there's anything besides a list delimiter, we've reached the end of the list
				{
					break;	//stop parsing the list
				}
			}
			return resourceList;	//return the parsed resources
		}
		return emptyList();	//the list is empty; return an empty list
	}

	/**Parses a label surrounded by label delimiters.
	The current position must be that of the first label delimiter character.
	The new position will be that immediately after the last label delimiter character.
	@param reader The reader the contents of which to be parsed.
	@return The label parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if one of the label characters is not a name character, or the reader has no more characters before the current label is completely parsed.
	*/
	public static String parseLabel(final Reader reader) throws IOException, ParseIOException
	{
		check(reader, LABEL_BEGIN);	//read the beginning label delimiter
		final String label=parseName(reader);	//read the label
		check(reader, LABEL_END);	//read the ending label delimiter
		return label;	//return the label we read
	}

	/**Parses a reference to a resource and returns the URI the reference represents, if any.
	For references, the current position must be that of the first character of the reference.
	If a reference was parsed, the new position will be that of the first non-separator character after the reference or the end of the reader.
	If no reference was encountered, the new position will be the same as the old position.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@return The reference parsed from the reader, or <code>null</code> if there is no reference at the current position.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current reference is completely parsed.
	@exception DataException if there was an error with information being processed.
	*/
	protected URI parseReference(final Reader reader, final URI baseURI) throws IOException, ParseIOException, DataException
	{
		return parseReference(reader, baseURI, null, (Map<String, URI>)EMPTY_MAP);	//parse a reference with no context URI or namespace prefixes
	}

	/**Parses a reference to a resource and returns the URI the reference represents, if any.
	For references, the current position must be that of the first character of the reference.
	If a reference was parsed, the new position will be that of the first non-separator character after the reference or the end of the reader.
	If no reference was encountered, the new position will be the same as the old position.
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param defaultNamespaceURI The URI of the default namespace, or <code>null</code> if no default namespace is allowed; for properties, this is the URI of the first type short form.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The reference parsed from the reader, or <code>null</code> if there is no reference at the current position.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current reference is completely parsed.
	@exception DataException if there was an error with information being processed.
	*/
	protected URI parseReference(final Reader reader, final URI baseURI, final URI defaultNamespaceURI, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException, DataException
	{
		final int c=peek(reader);	//peek the next character
		switch(c)	//check for a reference or a short form
		{
			case REFERENCE_BEGIN:
				return parseURI(reader, baseURI, REFERENCE_BEGIN, REFERENCE_END, prefixNamespaceURIMap);	//parse the resource URI
			case BINARY_BEGIN:	//binary
				{
					final byte[] binary=parseBinary(reader);	//parse the binary data
					return createBinaryURI(binary);	//create a URI for the resource
				}
			case BOOLEAN_BEGIN:	//boolean
				{
					final boolean b=parseBoolean(reader);	//parse the boolean
					return createLexicalURI(BOOLEAN_CLASS_URI, Boolean.toString(b));	//create a URI for the resource
				}
			case NUMBER_BEGIN:	//number
				{
					final Number number=parseNumber(reader, NUMBER_BEGIN, NUMBER_END, true, true, true);	//parse the number, allowing negative, decimal, and exponents
					final URI lexicalTypeURI;	//determine which type of number this is
					if(number instanceof Integer || number instanceof Long || number instanceof BigInteger)	//if this is an integer
					{
						lexicalTypeURI=INTEGER_CLASS_URI;	//we'll create an integer URI for the resource
					}
					else if(number instanceof Float || number instanceof Double || number instanceof BigDecimal)	//if this is an real
					{
						lexicalTypeURI=REAL_CLASS_URI;	//create a real URI for the resource
					}
					else	//if we don't recognize the number type
					{
						throw new AssertionError("Unrecognized number type produced: "+number.getClass());
					}
					return createLexicalURI(lexicalTypeURI, number.toString());	//create a URI for the resource
				}
			case ORDINAL_BEGIN:	//number
				{
					final Number ordinal=parseNumber(reader, ORDINAL_BEGIN, ORDINAL_END, false, false, false);	//parse the number, only allowing positive integers (which should produce an integer object)
					return createOrdinalURI(ordinal.longValue());	//create an ordinal URI for the resource
				}
			case REGULAR_EXPRESSION_BEGIN:	//regular expression
				{
					final String regularExpressionString=parseString(reader, REGULAR_EXPRESSION_BEGIN, REGULAR_EXPRESSION_END);	//parse the regular expression string
					return createLexicalURI(REGULAR_EXPRESSION_CLASS_URI, regularExpressionString);	//create a URI for the regular expression
				}
			case STRING_BEGIN:	//string
				{
					final String string=parseString(reader, STRING_BEGIN, STRING_END);	//parse the string
					return createLexicalURI(STRING_CLASS_URI, string);	//create a URI for the string
				}
			case TEMPORAL_BEGIN:	//temporal
				return parseTemporal(reader);	//parse the temporal
			case URI_BEGIN:	//URI
				{
					final URI uri=parseURI(reader, baseURI, URI_BEGIN, URI_END, prefixNamespaceURIMap);	//parse the URI
					return createLexicalURI(URI_CLASS_URI, uri.toString());	//create a URI for the resource
				}
			default:	//if there was some other character, see if it's a name reference
				if(isNameBeginCharacter(c))	//if this is a name begin character
				{
					final NameValuePair<String, String> name=parseNameReference(reader);	//parse the name reference
					final URI namespaceURI;	//we'll determine the namespace URI
					final String prefix=name.getName();	//get the name prefix
					final String localName=name.getValue();	//get the name local name
					if(prefix!=null)	//if there is a prefix, see to which namespace URI it refers
					{
						namespaceURI=prefixNamespaceURIMap.get(prefix);	//lookup up the namespace URI from the prefix
						if(namespaceURI==null)	//if there is no namespace URI defined for this prefix
						{
							throw new DataException("No namespace URI defined for prefix "+prefix+".");
						}
					}
					else	//if there is no prefix, get the default namespace for this context
					{
						if(defaultNamespaceURI==null)	//if no default namespace is available
						{
							throw new DataException("Local name "+localName+" has no context for default namespace determination.");
						}
						namespaceURI=defaultNamespaceURI;	//use the default namespace URI
					}
					try
					{
						return createResourceURI(namespaceURI, localName);	//create the resource URI from the namespace URI and local name
					}
					catch(final IllegalArgumentException illegalArgumentException)	//if the given namespace is not valid
					{
						if(prefix!=null)	//if a prefix was given
						{
							throw new DataException("Prefix "+prefix+" for local name "+localName+" references invalid namespace "+namespaceURI);
						}
						else	//if no prefix was given
						{
							throw new DataException("URI "+namespaceURI+" is not a valid default namespace URI for local name "+localName);						
						}
					}
				}
				break;
		}
		return null;	//indicate that there is no resource reference at the current position
	}
	
	/**Parses a name reference composed of name characters preceded by an optional prefix.
	The current position must be that of the first name character.
	The new position will be that immediately after the last name character.
	@param reader The reader the contents of which to be parsed.
	@return The name reference parsed from the reader, with the name of the name-value pair indicating the prefix or <code>null</code>, and the value representing the local name.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if thare are no name characters.
	*/
	public static NameValuePair<String, String> parseNameReference(final Reader reader) throws IOException, ParseIOException
	{
		final String nameSegment=parseName(reader);	//parse a name segment
		final String prefix, localName;	//we'll determine a prefix and a local name
		if(confirm(reader, NAME_PREFIX_DELIMITER))	//if there is a name prefix delimiter
		{
			prefix=nameSegment;	//the first name segment is the prefix
			localName=parseName(reader);	//the following name segment is the local name
		}
		else	//if there is no name prefix delimiter
		{
			prefix=null;	//there is no prefix
			localName=nameSegment;	//the name segment is the local name
		}
		return new NameValuePair<String, String>(prefix, localName);	//return the prefix, if any, and the local name
	}

	/**Parses a name composed of a name beginning character followed by zero or more name characters.
	The current position must be that of the first name character.
	The new position will be that immediately after the last name character.
	@param reader The reader the contents of which to be parsed.
	@return The name parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if thare are no name characters.
	@see TURF#isNameBeginCharacter(int)
	@see TURF#isNameCharacter(int)
	*/
	public static String parseName(final Reader reader) throws IOException, ParseIOException
	{
		final StringBuilder stringBuilder=new StringBuilder();	//create a string builder for reading the name segment
		int c=reader.read();	//read the first name character
		if(!isNameBeginCharacter(c))	//if the name doesn't start with a name character
		{
			checkReaderNotEnd(reader, c);	//make sure we're not at the end of the reader
			throw new ParseIOException(reader, "Expected name begin character; found "+(char)c+".");
		}
		do
		{
			stringBuilder.append((char)c);	//append the character
			reader.mark(1);	//mark our current position
			c=reader.read();	//read another character
		}
		while(isNameCharacter(c));	//keep reading and appending until we reach a non-name character
		if(c>=0)	//if we didn't reach the end of the stream
		{
			reader.reset();	//reset to the last mark, which was set right before the non-name character we found
		}
		return stringBuilder.toString();	//return the name segment we read
	}

	/**Parses binary data surrounded by binary delimiters.
	The current position must be that of the first binary delimiter character.
	The new position will be that immediately after the last binary delimiter character.
	@param reader The reader the contents of which to be parsed.
	@return The binary data parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current URI is completely parsed.
	@exception DataException if the binary data is not correctly encoded base64url data with no linebreaks or if the reader has no more characters before the current binary data is completely parsed.
	*/
	public static byte[] parseBinary(final Reader reader) throws IOException, ParseIOException, DataException
	{
		check(reader, BINARY_BEGIN);	//read the beginning binary delimiter
		final String base64urlString=reachAfter(reader, BINARY_END);	//read the rest of the binary data
		try
		{
			return Base64.decode(base64urlString.getBytes(UTF_8), 0, base64urlString.length(), Base64.URL_SAFE&Base64.DONT_BREAK_LINES);	//decode and return the data
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if the string was not valid base64url-encoded data
		{
			throw new DataException(illegalArgumentException);
		}
	}

	/**Parses a boolean surrounded by boolean delimiters.
	The current position must be that of the beginning boolean delimiter character.
	The new position will be that immediately after the last boolean character.
	@param reader The reader the contents of which to be parsed.
	@return The boolean parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the boolean is not syntactically correct or if the reader has no more characters before the current boolean is completely parsed.
	*/
	public static boolean parseBoolean(final Reader reader) throws IOException, ParseIOException
	{
		check(reader, BOOLEAN_BEGIN);	//read the beginning boolean delimiter
		final boolean b;	//we'll store the boolean here
		int c=peek(reader);	//peek the next character
		switch(c)	//see what the next character is
		{
			case BOOLEAN_FALSE_BEGIN:	//false
				check(reader, BOOLEAN_FALSE_LEXICAL_FORM);	//make sure this is really false
				b=false;	//store the boolean value
				break;
			case BOOLEAN_TRUE_BEGIN:	//true
				check(reader, BOOLEAN_TRUE_LEXICAL_FORM);	//make sure this is really true
				b=true;	//store the boolean value
				break;
			default:	//if we don't recognize the start of the boolean lexical form
				checkReaderNotEnd(reader, c);	//make sure we're not at the end of the reader
				throw new ParseIOException(reader, "Unrecognized start of boolean: "+(char)c);
		}
		check(reader, BOOLEAN_END);	//read the ending boolean delimiter
		return b;	//return the boolean we read
	}

	/**Parses a number beginning with a number delimiter.
	The current position must be that of the beginning number delimiter character.
	The new position will be that immediately after the last number character.
	This implementation returns a {@link Long} for all values with no decimal or exponent, and a {@link Double} for all other values.
	@param reader The reader the contents of which to be parsed.
	@param numberBegin The beginning number delimiter.
	@param numberEnd The ending number delimiter.
	@param allowMinus Whether the number allows an optional introductory minus sign.
	@param allowDecimal Whether the number allows an optional decimal part.
	@param allowExponent Whether the number allows an optional exponent part.
	@return The number parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current number is completely parsed.
	@exception DataException if the number is not of the correct format.
	*/
	public static Number parseNumber(final Reader reader, final char numberBegin, final char numberEnd, final boolean allowMinus, final boolean allowDecimal, final boolean allowExponent) throws IOException, ParseIOException, DataException
	{
		boolean hasFraction=false;	//we don't have a fraction yet
		boolean hasExponent=false;	//we don't have an exponent yet
		check(reader, numberBegin);	//read the beginning number delimiter
		int c;	//we'll use this to keep track of the next character
		final StringBuilder stringBuilder=new StringBuilder();	//create a new string builder to use when reading the number
		if(allowMinus)	//if we should allow the minus sign
		{
			c=peek(reader);	//peek the first character
			if(c=='-')	//if the number starts with a minus sign
			{
				stringBuilder.append(check(reader, '-'));	//append the character
			}
		}
		stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
		c=peek(reader);	//peek the next character
		if(c>=0)	//if we're not at the end of the reader
		{
			if(allowDecimal && c==DECIMAL_DELIMITER)	//if we should allow a decimal part and this is a floating point number
			{
				hasFraction=true;	//we found a fraction
				stringBuilder.append(check(reader, DECIMAL_DELIMITER));	//read and append the beginning decimal point
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				c=peek(reader);	//peek the next character
			}
			if(allowExponent && c==EXPONENT_DELIMITER)	//if we should allow an exponent part and this is an exponent
			{
				hasExponent=true;	//we found an exponent
				stringBuilder.append(check(reader, EXPONENT_DELIMITER));	//read and append the exponent character
				c=peek(reader);	//peek the next character
				if(c=='-' || c=='+')	//if the exponent starts with a sign
				{
					stringBuilder.append(readCharacter(reader));	//append the sign
				}
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
			}
		}
		check(reader, numberEnd);	//read the ending number delimiter
		try
		{
			final String numberString=stringBuilder.toString();	//convert the number to a string
			if(hasFraction || hasExponent)	//if there was a fraction or exponent
			{
				return Double.valueOf(Double.parseDouble(numberString));	//parse a double and return it
			}
			else	//if there is no fraction or exponent
			{
				return Long.valueOf(Long.parseLong(numberString));	//parse a long and return it
			}
		}
		catch(final NumberFormatException numberFormatException)	//if the number was not syntactically correct
		{
			throw new DataException(numberFormatException);
		}
	}

	/**Parses a temporal beginning with the temporal delimiter.
	The current position must be that of the beginning temporal delimiter character.
	The new position will be that immediately after the last temporal character.
	@param reader The reader the contents of which to be parsed.
	@return The URI of the temporal parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current temporal is completely parsed.
	@exception DataException if the temporal is not of the correct format.
	*/
	public static URI parseTemporal(final Reader reader) throws IOException, ParseIOException, DataException
	{
		check(reader, TEMPORAL_BEGIN);	//read the beginning temporal delimiter
		int c;	//we'll use this to keep track of the next character
		final StringBuilder stringBuilder=new StringBuilder();	//create a new string builder to use when reading the temporal
		final URI lexicalTypeURI;	//determine which type of temporal this is
		c=peek(reader);	//peek the first character
		if(c==DURATION_LEXICAL_FORM_BEGIN)	//if this temporal starts with a duration delimiter
		{
			lexicalTypeURI=DURATION_CLASS_URI;	//this is a duration
			stringBuilder.append(check(reader, DURATION_LEXICAL_FORM_BEGIN));	//read and add the delimiter
			boolean hasComponent=false;	//we'll see if the duration has some component
			c=peek(reader);	//peek the next character
			if(c!=TIME_BEGIN)	//if this is not the beginning of a time
			{
				hasComponent=true;	//indicate that there is some duration component
					//years
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				stringBuilder.append(check(reader, DURATION_YEARS_DELIMITER));	//read and add the delimiter
					//months
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				stringBuilder.append(check(reader, DURATION_MONTHS_DELIMITER));	//read and add the delimiter
					//days
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				stringBuilder.append(check(reader, DURATION_DAYS_DELIMITER));	//read and add the delimiter
				c=peek(reader);	//peek the next character
			}
			if(c==TIME_BEGIN)	//if this is the beginning of a time
			{
				hasComponent=true;	//indicate that there is some duration component
				stringBuilder.append(check(reader, TIME_BEGIN));	//read and append the time delimiter
					//hours
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				stringBuilder.append(check(reader, DURATION_HOURS_DELIMITER));	//read and add the delimiter
					//minutes
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				stringBuilder.append(check(reader, DURATION_MINUTES_DELIMITER));	//read and add the delimiter
					//seconds
				stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				c=peek(reader);	//peek the next character
				if(c==DECIMAL_DELIMITER)	//if this is a decimal delimiter
				{
					stringBuilder.append(check(reader, DECIMAL_DELIMITER));	//read and append the time delimiter
					stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all digits; there should be at least one
				}
				stringBuilder.append(check(reader, DURATION_SECONDS_DELIMITER));	//read and add the delimiter
			}
			if(!hasComponent)	//if there is no duration component
			{
				throw new DataException("Duration cannot be empty.");
			}
		}
		else if(c=='+' || c=='-')	//if this is the start of a UTC offset
		{
			lexicalTypeURI=UTC_OFFSET_CLASS_URI;	//this is a UTC offset
			stringBuilder.append(check(reader, (char)c));	//read and add the delimiter
			stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read two digits
			stringBuilder.append(check(reader, TIME_DELIMITER));	//read and add the time delimiter
			stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read two digits
		}
		else	//this is a date, a time, or a date time
		{
			String dateTimeStart=readMinimum(reader, 1, '0', '9'); //read all digits; there should be at least one
			final int dateTimeStartLength=dateTimeStart.length();	//get the length of the date time start
			final boolean hasTime;	//determine if there is a time
			if(dateTimeStartLength==4)	//we've started a date
			{
				stringBuilder.append(dateTimeStart); //append the beginning date time characters
				stringBuilder.append(check(reader, DATE_DELIMITER));	//read and add the date delimiter
				stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read the month
				stringBuilder.append(check(reader, DATE_DELIMITER));	//read and add the date delimiter
				stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read the day
				c=peek(reader);	//peek the next character
				if(c==TIME_BEGIN)	//if this is the beginning of a time
				{
					lexicalTypeURI=DATE_TIME_CLASS_URI;	//this is a date time
					stringBuilder.append(check(reader, TIME_BEGIN));	//read and append the time delimiter
					dateTimeStart=readStringCheck(reader, 2, '0', '9'); //read the hour, and then let the time code take over
					hasTime=true;	//we still have time to parse
				}
				else	//if this is only a date
				{
					lexicalTypeURI=DATE_CLASS_URI;	//this is a date
					hasTime=false;	//there is no time to parse
				}					
			}
			else	//if we didn't start a date
			{
				if(dateTimeStartLength==2)	//if we're starting a time
				{
					lexicalTypeURI=TIME_CLASS_URI;	//this is a time
					hasTime=true;	//we need to parse the time
				}
				else	//if this is neither the start of a date nor the start of a time
				{
					throw new DataException("Incorrect start of a date, time, or date time: "+dateTimeStart);
				}
			}
			if(hasTime)	//if we need to parse time
			{
				stringBuilder.append(dateTimeStart); //append the beginning date time characters
				stringBuilder.append(check(reader, TIME_DELIMITER));	//read and add the time delimiter
				stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read the minutes
				stringBuilder.append(check(reader, TIME_DELIMITER));	//read and add the time delimiter
				stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read the seconds
				c=peek(reader);	//peek the next character
				if(c==DECIMAL_DELIMITER)	//if this is a decimal delimiter
				{
					stringBuilder.append(check(reader, DECIMAL_DELIMITER));	//read and append the time delimiter
					stringBuilder.append(readMinimum(reader, 1, '0', '9')); //read all subseconds
				}
				c=peek(reader);	//peek the next character
				if(c=='+' || c=='-')	//if this is the start of a UTC offset
				{
					stringBuilder.append(check(reader, (char)c));	//read and add the delimiter
					stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read two digits
					stringBuilder.append(check(reader, TIME_DELIMITER));	//read and add the time delimiter
					stringBuilder.append(readStringCheck(reader, 2, '0', '9')); //read two digits
				}
			}
		}
		check(reader, TEMPORAL_END);	//read the ending temporal delimiter
		return createLexicalURI(lexicalTypeURI, stringBuilder.toString());	//create and return a URI for the temporal
	}

	/**Parses a string surrounded by string delimiters.
	The current position must be that of the first string delimiter character.
	The new position will be that immediately after the string number delimiter character.
	@param reader The reader the contents of which to be parsed.
	@param stringBegin The beginning string delimiter.
	@param stringEnd The ending string delimiter.
	@return The string parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the string is not escaped correctly or reader has no more characters before the current string is completely parsed.
	@exception DataException if the string is not of the correct format.
	*/
	public static String parseString(final Reader reader, final char stringBegin, final char stringEnd) throws IOException, ParseIOException, DataException
	{
		check(reader, stringBegin);	//read the beginning string delimiter
		final StringBuilder stringBuilder=new StringBuilder();	//create a new string builder to use when reading the string
		char c=readCharacter(reader);	//read a character
		while(c!=stringEnd)	//keep reading character until we reach the end of the string
		{
			if(c==STRING_ESCAPE)	//if this is an escape character
			{
				c=readCharacter(reader);	//read another a character
				switch(c)	//see what the next character
				{
					case STRING_ESCAPE:	//escape character
						break;	//use the escaped escape character unmodified
					case ESCAPED_BACKSPACE:	//b backspace
						c=BACKSPACE_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_FORM_FEED:	//f form feed
						c=FORM_FEED_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_LINE_FEED:	//n line feed
						c=LINE_FEED_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_CARRIAGE_RETURN:	//r carriage return
						c=CARRIAGE_RETURN_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_TAB:	//t tab
						c=HORIZONTAL_TABULATION_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_START_OF_STRING:	//left double quotation mark start of string
						c=START_OF_STRING_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_STRING_TERMINATOR:	//right double quotation mark string terminator
						c=STRING_TERMINATOR_CHAR;	//use the character that was escaped
						break;
					case ESCAPED_UNICODE:	//u Unicode
						{
							final String unicodeString=readString(reader, 4);	//read the four Unicode code point hex characters
							final int unicodeStringLength=unicodeString.length();	//get the length of the Unicode string
							for(int i=0; i<unicodeStringLength; ++i)	//look at the characters to make sure they are not lowercase
							try
							{
								final char hex=unicodeString.charAt(i);	//get this hex character
								if(hex>='A' || hex<='F')	//if this is an uppercase hex character
								{
									throw new DataException("Uppercase escape Unicode character not allowed: "+hex);
								}
								c=(char)Integer.parseInt(unicodeString, 16);	//parse the hex characters and use the resulting code point
							}
							catch(final NumberFormatException numberFormatException)	//if the hex integer was not in the correct format
							{
								throw new DataException(numberFormatException);
							}
						}
						break;
					default:	//if another character was escaped
						if(c!=stringBegin && c!=stringEnd)	//if this is not the delimiter that was escaped
						{
							throw new DataException("Unknown escaped character: "+(char)c);
						}
						break;
				}
			}
			stringBuilder.append(c);	//append the character to the string we are constructing
			c=readCharacter(reader);	//read another a character
		}
		return stringBuilder.toString();	//return the string we constructed
	}

	/**Parses a URI surrounded by specified URI delimiters.
	The current position must be that of the first URI delimiter character.
	The new position will be that immediately after the last URI delimiter character.
	The URI is resolved to the base URI, if any
	@param reader The reader the contents of which to be parsed.
	@param baseURI The base URI of the data, or <code>null</code> if no base URI is available.
	@param uriBegin The beginning URI delimiter.
	@param uriEnd The ending URI delimiter.
	@param prefixNamespaceURIMap The map of namespace URIs associated with prefixes; a new map containing the same information should be created if new namespaces should be added for a particular resource and it children.
	@return The URI parsed from the reader.
	@exception NullPointerException if the given reader is <code>null</code>.
	@exception IOException if there is an error reading from the reader.
	@exception ParseIOException if the reader has no more characters before the current URI is completely parsed.
	@exception DataException if the URI is not of the correct format.
	*/
	public URI parseURI(final Reader reader, final URI baseURI, final char uriBegin, final char uriEnd, final Map<String, URI> prefixNamespaceURIMap) throws IOException, ParseIOException, DataException
	{
		check(reader, uriBegin);	//read the beginning URI delimiter
		int c=peek(reader);	//peek the next character
		final String lexicalForm;	//the lexical form, if any
		final URI uri;	//we'll store the unresolve URI here
		try
		{
			if(c==TYPES_BEGIN)	//if the URI begins with a type declaration
			{
				check(reader, TYPES_BEGIN);	//read the beginning type delimiter
				skipSeparators(reader);	//skip separators
				final Resource type=parseResource(reader, baseURI, null, null, null, prefixNamespaceURIMap);	//parse the type resource
				final URI typeURI=type.getURI();	//get the URI of the type
				if(typeURI==null)	//if no type URI was provided
				{
					throw new DataException("Lexical URI provided no type URI.");
				}
				check(reader, TYPES_END);	//read the ending type delimiter
				skipSeparators(reader);	//skip separators
				lexicalForm=parseString(reader, STRING_BEGIN,	STRING_END);	//parse the lexical form, which must appear next
				skipSeparators(reader);	//skip separators
				check(reader, uriEnd);	//read the ending URI delimiter
				uri=createLexicalURI(typeURI, lexicalForm);	//create a lexical URI using the lexical form and the type URI
			}
			else	//if no type was encountered
			{
				uri=new URI(reachAfter(reader, uriEnd));	//read the rest of the URI normally
			}
		}
		catch(final IllegalArgumentException illegalArgumentException)	//if we couldn't create a correct lexical URI
		{
			throw new DataException(illegalArgumentException);
		}
		catch(final URISyntaxException uriSyntaxException)	//if one of the strings was not a valid URI
		{
			throw new DataException(uriSyntaxException);
		}
		return baseURI!=null ? resolve(baseURI, uri) : uri;	//return the URI, resolved against the base URI if there is a base URI
	}

}